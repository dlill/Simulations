---
title: "Enzymatic Cascade"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---


```{r setup, results='hide', echo=FALSE, message=FALSE}
# Load libraries and define some useful paths
# rm(list = ls())
library(MRAr)
library(scales)
library(xtable)
```


# Setup Model 

Careful, it might be broken due to the new comple Cx1z2 in the model...

## Prediction function
odemodel() writes the function f as a C-function, which is called by x and xs.
```{r, results='asis'}
f     <- "model.csv" %>% 
  read.csv %>%
  .[1:16,] %>% #kick out synthesis and degradation
  as.eqnlist

# If the odemodel has been calculated already, it can be loaded with "load".
# If not, uncomment the next two lines.
# myodemodel <- odemodel(f, modelname = "cascade_comprehensive")
# saveRDS(myodemodel, "odemodel.rds")
myodemodel <- readRDS("odemodel.rds")

# Prediction function for continuous times
# x() is a function of time and parameters
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
# print(f, pander= T)
```


## Observation function
Observation function which returns our communicating species. 
The free parameters a_ij are introduced here to perform the linear combination of states which we wish to observe.
We chose to call them pars_opt, since they will be used to optimize the objective function later on.
```{r Most general observation function}
modules <- modules0 <- c("X","Y", "Z")

mypars_opt <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("x2y1","y2z1","z2x1", "z2x2", "z2y2", "y2x2"), paste0)) %>% matrix(nrow=3)

mypars_opt[c(2,3, 
             4,6, 
             8,
             11,
             13,
             18)] <- "0"

mycomplexes <- matrix(paste0("C", c("x2y1","y2z1","z2x1", "z2x2", "z2y2", "y2x2")), ncol = 1)

# samepars_opt <- paste0("a_", outer(rep("C",3), c("xy","yz","x1z", "x2z"), paste0)) %>% matrix(ncol=4)
# samepars_opt[c(3,4,8,11)] <- "0"

obs <- obs0 <- paste(c("x2", "y2", "z2"), "+", prodSymb(mypars_opt, mycomplexes)
                     # , "+", prodSymb(samepars_opt, mycomplexes)
                     )

g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), f, compile = TRUE, modelname = "obs", attach.input = FALSE)
```

Fluxes
```{r}
fluxes <- f %>% 
  as.data.frame() %>%
  {structure(.$Rate, names = .$Description %>% str_replace_all(" ", "_"))} %>% 
  # names %>%
  .[c(1:14)]

```









# Apply the algorithm interactively

## Parameter set 1

The first parameter set doesn't include the positive feedback from z to x. 
However, all other complexes are about equally strong.
```{r, message=FALSE}
pinner <- list(
  # old model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	100	,
v1         	=	5	,
k2         	=	100	,
v2         	=	c(5,
                5)	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	100	,
v5         	=	5	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	100	,
v8         	=	1	,

k9         	=	100	,
k10        	=	100	,
gainuf     	=	1	,
gainlf     	=	1	,

# new complexes
kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

kzx1_1     	=	c(0, 
                0.01)	,
kzx1_2     	=	0.4	,
kzx1       	=	0.05	,

kzx        	=	0.01	,
kzx2       	=	0.4	,
kzx1_3     	=	0.05	,

kzy1       	=	0.01	,
kzy2       	=	0.4	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)

pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log
pars_opt <- pars %>% str_subset_name("a_to")


trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()


# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)


cat("out\n")
(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

times <- seq(0,1000, length.out = 100)
(x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
  plotPrediction(
scales = "fixed"
)

# plotFluxes(pars, (x*p*p_pert), times, fluxes, conditions = "Ctr")
# ggplotly()


# build dMod.frame
myframe <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))

```

### Results of the interactive exploration

Start an interactive interface, where you can choose alpha-values and the optimization parameters
```{r}
source('../../gadget.R', echo=TRUE)
ropt_gadget(pars_opt %>% names, myframe)
```

Combinations

1. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------
    + r_0 has the correct signs, except of course for the retroactive connection r31, which should be zero but isn't
    - The first element to be tuned in, however, is the element r23. Therefore, the retroactive connection from z to y is stronger than the direct feedback. This element can also be optimized away.
    + The second element is r31 and it is correctly optimized away.
    - Then, r12 is tuned into the optimization, which is similar to r23. It is also optimized away. 
    + At higher alpha, r21 and r32 are kept in the optimization, indicating some retroactivity between x <-> y and y <-> z.
        - However, the optimized matrix is bullshit: r31 reappears, same as r23, but with wrong sign.
    * Summary: Activatory connections win and are not optimized away, short feedbacks can be detected even without including the corresponding complexes, but are not optimized away.
    
2. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, a_toz_Cz2y2
    * Basically, this behavior is the same as with only the three complexes

3. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, -----------
    * Basically, the same behaviour as the setting before
    
4. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, a_toz_Cz2y2
    + First, r12 and r23 are tuned in, then r31. This is all normal, but doesn't include the short feedbacks yet
    + Then, r32 is included (y to z), but this object can't be optimized away. 
      This means, that there is some retroactivity detected on the short feedback, but it can't win against the activation
    - Then, when alpha is increased, r31 and r32 start vanishing again. This means: "No retroactivity on the connection z to y" and than "z to x" is also retroactivity free
    + However, except for the retroactive connection r31, all the signs are correct.

5. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2
    * Qualitatively similar behaviour as in the first three settings

6. a_tox_Cx2y1, -----------, -----------, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2
    * Only element r31 is kept and also optimized away, all other connections have the correct sign



## Parameter set 2

This parameter set decreases the intrinsic deactivation of x2 and y2 in comparison to parameter set 1. 
Furthermore, the complex Cz2y2 association rate kzy1 is increased while the dissociation rate kzy2 is decreased, 
  such that there is more sequestration in this complex.
```{r, message=FALSE}
pinner <- list(
  # old model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	100	,
v1         	=	5	,
k2         	=	100	,
v2         	=	.5	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	100	,
v5         	=	.5	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	100	,
v8         	=	1	,

k9         	=	100	,
k10        	=	100	,
gainuf     	=	1	,
gainlf     	=	1	,

# new complexes
kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

kzx1_1     	=	0	,
kzx1_2     	=	0.4	,
kzx1       	=	0.05	,

kzx        	=	0.01	,
kzx2       	=	0.4	,
kzx1_3     	=	0.05	,

kzy1       	=	0.04	,
kzy2       	=	0.2	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)


pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log
pars_opt <- pars %>% str_subset_name("a_to")


trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()


# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)

cat("out\n")
(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

# times <- seq(0,1000, length.out = 100)
(x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
  plotPrediction(
scales = "fixed"
)

# plotFluxes(pars, (x*p*p_pert), times, fluxes, conditions = "Ctr")
# ggplotly()


# build dMod.frame
myframe2 <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))

```

### Results of the interactive exploration

Start an interactive interface, where you can choose alpha-values and the optimization parameters
```{r}
source('../../gadget.R', echo=TRUE)
pars_to_check <- pars_opt %>% names %>% str_subset_not("Cz2x1")
ropt_gadget(pars_to_check, myframe2)
```

Combinations

1. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------
    - Around alpha = -.748, the matrices seem to have difficulties to be calculated during the optimization, maybe there is a problem with the inversion? (Looks like columns 1 and 2 are nearly parallel in the optimized matrix.)
    - At alpha = -.748, r31 and r32 are kept in the optimization, but this is really weird: r32 is y -> z activation. Also the optimized result is weird: r12 is positive even though it should be a negative feedback.  Also, r13 is positive, but this should also be a negative feedback.
    
2. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, a_toz_Cz2y2

3. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, -----------

4. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, a_toz_Cz2y2
    - First element is r12 (alpha ~ -.634) . 
        -Some of the pars_opt are definitely not identifiable, because the results change a lot, when I let it fit different times. (click left or right arrows after using the slider to incearse/decrease slider values by 0.001, which doesn't change r_kept, but restarts the optimization)
        - Indeed, even r21 sometimes flips its sign or sometimes is as large as 40 which points to a non-identifiability.
    - Then r31 comes into play (alpha ~-.468), same problem with non-identifiable parameters, but at least the matrices are similar
    - Then, r13 is added, but this can't be optimized away, neither is r12 then, but instead r21 is optimized away. Furthermore r23 has a positive sign which it shouldn't have
        - Often, the optimization doesn't work, some parameters are pushed to +/- Inf. Maybe try using a prior around zero? 
    - Later, r31 vanishes from the optimization again and only the top row is kept (r12 and r13). Results are weird, since the transposed elements are minimized somehow? (14_04 o'clock)
    
    
5. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2

6. a_tox_Cx2y1, -----------, -----------, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2






# Explore the numerical sensitivities

If one imagines that one does a linear combination of the rows of the global responses with positive free parameters, one can see that some connections can be brought to zero, since 

```{r, message=FALSE}
pinner <- list(
  # old model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	100	,
v1         	=	5	,
k2         	=	100	,
v2         	=	c(5,
                5)	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	100	,
v5         	=	5	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	100	,
v8         	=	1	,

k9         	=	100	,
k10        	=	100	,
gainuf     	=	1	,
gainlf     	=	1	,

# new complexes
kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

kzx1_1     	=	c(0, 
                0.01)	,
kzx1_2     	=	0.4	,
kzx1       	=	0.05	,

kzx        	=	0.01	,
kzx2       	=	0.4	,
kzx1_3     	=	0.05	,

kzy1       	=	0.01	,
kzy2       	=	0.4	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)

pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")
          # , str_subset_name(pinner,"v1")
          ) %>% log
pars_opt <- pars %>% str_subset_name("a_to")


trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()


# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)


cat("out\n")
(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

times <- seq(0,1000, length.out = 100)
(x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
  plotPrediction(
scales = "fixed"
)

# plotFluxes(pars, (x*p*p_pert), times, fluxes, conditions = "Ctr")
# ggplotly()


# build dMod.frame
myframe <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))

```





```{r}
# 
pred <- (xs*p*p_pert)(c(0,Inf), pars, deriv = T)
# pred %>% getDerivs()
states <- f$states

cat("Global responses\n")

conveniencefunctions::extract_derivs(pred, states, states) %>%
  .[[1]] %>%
  .[-1] %>%
  matrix(ncol = 3) %>%

  
  {out <- .; map(1:3, function(i) out[,i]/out[i,i])} %>%
  do.call(cbind,.) %>%

  round(2) %>% 
  
  # sign %>% 
  magrittr::set_rownames(states) %>%
  magrittr::set_colnames(paste0(letters[24:26], "1")) %>% 
  
  # {.} %T>% print %>%
  {.}
```

```{r}
values <- seq(log(0.1), log(500), length.out = 100)

dr <- map(values, function(v) {
  mypars <- pars
  mypars["x1"] <- values
  
  pred <- (xs*p*p_pert)(c(0,Inf), mypars, deriv = F, conditions = "Ctr")[[1]]
}) %>% 
  do.call(rbind,.) %>% 
  cbind(xini = values) %>% 
  as.data.frame() %>% 
  .[-1] %>% 
  gather(state, value, -contains("xini"))

dr %>% 
  filter(str_detect(state, "z")) %>% 
  ggplot(aes(exp(xini), value, color = state)) +
  geom_line()
```

```{r}
pars["x1"] <- log(10)
myframe <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))


source('../../gadget.R', echo=TRUE)
ropt_gadget(pars_opt %>% names, myframe)

```


```{r}
whichParOpt <- names(pars_opt)[c(1,5)]
perturbation_prediction <- (xs*p*p_pert)(c(0,Inf), pars, deriv = F)

r0 <- R_fun(pars_opt = pars_opt,
            perturbation_prediction = perturbation_prediction,
            obs_fun = g,
            p_fun = (p*p_pert),
            pars = pars) %>% local_response_matrix_eq10()

rkept <- r_kept_fun(pars_opt = pars_opt[whichParOpt],
                                        perturbation_prediction = perturbation_prediction, 
                                        obs_fun = g,
                                        p_fun = (p * p_pert), 
                                        pars = pars,
                                        alpha = 
                                   -log(.Machine$double.eps)) %>% 
  {.} %T>% print %>%
  {.}
myfits <- mstrust(obj_alpha, 
                        center =  structure(rep(0, length(whichParOpt)), names = whichParOpt), 
                        studyname = "Fits", 
                        cores = 3, 
                        fits = 12, 
                        sd = 1, 
                        mypars = pars, 
                        perturbation_prediction = perturbation_prediction, 
                        r_kept = rkept, 
                        p_fun = (p * p_pert),
                        obs_fun = g)
myfits %>% as.parframe()
```







# Use the Japanese guys' structural analysis

## Analytically - prepare Mathematica objects

Name of their paper: Sensitivity and network topology in chemical reaction systems

Vocabulary of their paper:
M spezies m
R reactions j

Stoichiometrixc matrix nu_{m j}
c =  steady state fluxes, ker(s)

r_j = j-te Ratengleichung = "flux"
A  = matrix(dr_j/dx_m, 
            matrix(rbind(coefficients of conserved quantities)_{Nc M},
            matrix(cbind(coefficients of steady state fluxes)),
            0
            )

```{r}
f <- read.csv("modelJapanese.csv") %>% 
  .[-(20:22),] %>% select(-Cz2x1) %>% as.data.frame() %>%  
  as.eqnlist()

# simplify model: kick out z
# f <- f %>%
#   as.data.frame %>% 
#   filter(Description %>% str_detect("z") %>% `!`) %>% .[!str_detect(names(.), "z")] %>% 
#   as.eqnlist()
#   
# simplify model: simplify rate equations
myrates <- f$rates
myrates <-
  myrates %>%
    str_replace("\\* ?\\(.*", "") %>% # Optionally for Mathematica: kill regulatory feedback
    str_replace("v([0-9]*) *\\* *([x-z][12]).*", "k\\1 * \\2))") # Optionally for Mathematica: replace intrinsic Michaelis Menten activation by Mass Action activation
    {.}


# dr_j/dx_m
drdx <- jacobianSymb(myrates %>% setNames(.,paste0("j", 1:length(.))),f$states) %>%
  matrix(ncol = length(f$states))

# conserved moieties
conserved <-
  f$smatrix %>% replace(.,is.na(.), 0) %>% nullZ() %>% {rownames(.) <- f$states;.} %>%
# {out <- mymat <- .; out[,1] <- mymat[,2]+ mymat[,3];out[,2] <- mymat[,1]+ mymat[,3];out[,3] <- mymat[,2]+ mymat[,1]; out} %>% # for the full model
  {out <- mymat <- .; out[,2] <- mymat[,1]+ mymat[,2]; out[,1] <- mymat[,2]; out} %>% # for the full model
   t

# fluxes
fluxes <-
  f$smatrix %>% replace(.,is.na(.), 0) %>%t %>% nullZ()

# matrix of zeros
zeros <- matrix(0, nrow = nrow(conserved), ncol = ncol(fluxes))

# A
A <- cbind(rbind(drdx, -conserved), rbind(-fluxes, zeros))
#print A
A%>% print_mathematica.matrix("A")

# Matrices of eigensensitivities
symdiag <- function(vec) {
  mymat <- diag(1:length(vec))
  mymat[diag(1:length(vec))!=0] <- vec
  mymat
}
symdiag(paste0("Er", 1:length(f$rates))) %>% print_mathematica.matrix("ER")
symdiag(paste0("c", 1:nrow(conserved))) %>% print_mathematica.matrix("ENc")
```


## Numerically - interface to dMod

Unfortunately, things aren't so easy, as the paper by Okada et al assuma mass action kinetics in each reaction. Therefore, I first need to several things

1. Change equations to Mass action, and kill feedback
2. Find good parameters which resemble the original parameters
3. Apply their algorithm


```{r}
f <- read.csv("modelJapanese.csv") %>% 
  .[-(20:22),] %>% select(-Cz2x1) %>% as.data.frame() %>%  
  as.eqnlist()

f$rates <-
  f$rates %>%
    str_replace("\\* ?\\(.*", "") %>% # Optionally for Mathematica: kill regulatory feedback
    str_replace("v([0-9]*) *\\* *([x-z][12]).*", "k\\1 * \\2))") %>%  # Optionally for Mathematica: replace intrinsic Michaelis Menten activation by Mass Action activation
    {.}

model <- f %>% odemodel()

xs <- Xs_steady(model)
x <- Xs(model)
g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), f, compile = TRUE, modelname = "obs", attach.input = FALSE)

pinner <- list(
  # MA model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	.1	,
k2         	=	.01	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	.01	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	.01	,

kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

# kzx1_1     	=	c(0, 
#                 0.01)	,
# kzx1_2     	=	0.4	,
# kzx1_3     	=	0.05	,

kzx1       	=	0.05	,
kzx2       	=	0.4	,
kzx        	=	0.01	,


kzy1       	=	0.01	,
kzy2       	=	0.4	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)

pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log
pars_opt <- pars %>% str_subset_name("a_to")

trafo <-
  getParameters(g,x) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

  
p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()


# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)


cat("out\n")
(p*p_pert)(pars)
getParameters(p)

(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

times <- seq(0,400, length.out = 100)
(x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
  plotPrediction(
scales = "fixed"
)

# build dMod.frame
myframe <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))
  
```



```{r}
# dr_j/dx_m
drdx <- jacobianSymb(f$rates %>% setNames(.,paste0("j", 1:length(.))),f$states) %>%
  matrix(ncol = length(f$states))

# conserved moieties
conserved <-
  f$smatrix %>% replace(.,is.na(.), 0) %>% nullZ() %>% {rownames(.) <- f$states;.} %>%
  {out <- mymat <- .; out[,1] <- mymat[,2]+ mymat[,3];out[,3] <- mymat[,1]+ mymat[,3];out[,2] <- mymat[,2]+ mymat[,1]; out} %>% # for the full model
  t

# fluxes
fluxes <-
  f$smatrix %>% replace(.,is.na(.), 0) %>%t %>% nullZ()

# matrix of zeros
zeros <- matrix(0, nrow = nrow(conserved), ncol = ncol(fluxes))

# A
A <- cbind(rbind(drdx, -conserved), rbind(-fluxes, zeros))


# Make A a function which can be evaluated, use funC0 for that. 
mynames <- paste0("A_", outer(1:dim(A)[1], 1:dim(A)[2], FUN = paste, sep = "."))
A_fun <-  A %>% {attr(.,"dim") <- NULL;.} %>% setNames(mynames) %>% funC0()

# Get the steady state of the system
steady_state <- (xs*p*p_pert)(c(0,Inf),pars, conditions = "Ctr", deriv = F) %>% .[[1]] %>% .[,-1] %>% unlist()
inpars <- p(pars) %>% .[[1]] %>% unclass() %>% {attr(., "deriv") <- NULL;.} %>%   {out <- .; out[names(steady_state)] <- steady_state; out}

# Compute A
A_num <- do.call(A_fun, as.list(inpars)) %>% {dim(.) <- dim(A);.}

# Prepare the matrix of eigensensitivities
Er_Ec <- diag(rep(1, nrow(A)))


# check if A_num is ill conditioned, i.e. if it can be inverted without numerical problems
svd(A_num) %>% .$d %>%  {(max(.)/min(.))}

# Invert the matrix and get the eigensensitiviites
  # naming
dynpars <- getParameters(x) %>% setdiff(f$states)
moieties <- paste0(letters[24:26], "tot")
states <- f$states
flux_names <- paste0("flux",1:(dim(fluxes)[2]))

mysens <- (- svdinv(A_num) %*% Er_Ec) %>% {dimnames(.) <- list(c(states, flux_names), c(dynpars, moieties));.}

cat("Sensitivies\n")
dXdtot <- mysens %>% 
  .[1:length(states),] %>% # exclude fluxes
  .[,-(1:length(dynpars))] %>% 
  
  {out <- .; map(1:3, function(i) out[,i]/out[i,i])} %>%
  do.call(cbind,.) %>%

  round(2) %>% 
  
  # sign %>% 
  
  {.} %T>% print %>%
  {.}

sum(dXdtot[,1])
```

```{r}
R_fun(pars_opt, (xs*p*p_pert)(c(0,Inf),pars, deriv = F), g, (p*p_pert), pars) %>% 
  local_response_matrix_eq10()
```

```{r}
steady_state <- (xs*p*p_pert)(c(0,Inf),pars, deriv = F, conditions = "Ctr")[[1]][1,,drop = T]
```


```{r}
dXdtot[2,1] / # dx2/dxtot
  dXdtot[4,1] * # dy2/dxtot
  steady_state["y2"] / 
  steady_state["x2"]
```


## Results of the Japanese guys' method

Somehow I had forgotten that their approach delivers global responses, not local ones. However, what's nice about it is that they really get sensitivities for conserved moieties.
Next, I'm gonna try the local responses from the Jacobian directly




# Local responses from Jacobian

To get the sensitivities wrt the totals, one can easily do a parameter transformation of the states

Example: x = c(x1,x2), x' = c(xt',x2'). (Primes don't mean anything, they're just to make clear in which coordinates we are at the moment). 
Then x = c(x1,x2) = c(xt'-x2',x2') = matrix(1,0,-1,1, ncol = 2) %*% c(xt',x2') = M x'

(df/dx)_ij  --> (df/dx')_ij = (df/dx)_ik %*% (dx/dx')_kj = (dfdx)_ik %*% M_kj

[] implement the matrix M


```{r}
f <- read.csv("modelJapanese.csv") %>% 
  .[-(20:22),] %>% select(-Cz2x1) %>% as.data.frame() %>%  
  as.eqnlist()

f$rates <-
  f$rates %>%
    str_replace("\\* ?\\(.*", "") %>% # Optionally for Mathematica: kill regulatory feedback
    str_replace("v([0-9]*) *\\* *([x-z][12]).*", "k\\1 * \\2))") %>%  # Optionally for Mathematica: replace intrinsic Michaelis Menten activation by Mass Action activation
    {.}

model <- f %>% odemodel()

xs <- Xs_steady(model)
x <- Xs(model)
g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), f, compile = TRUE, modelname = "obs", attach.input = FALSE)

pinner <- list(
  # MA model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	.1	,
k2         	=	.01	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	.01	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	.01	,

kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

# kzx1_1     	=	c(0, 
#                 0.01)	,
# kzx1_2     	=	0.4	,
# kzx1_3     	=	0.05	,

kzx1       	=	0.05	,
kzx2       	=	0.4	,
kzx        	=	0.01	,


kzy1       	=	0.01	,
kzy2       	=	0.4	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)

pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log
pars_opt <- pars %>% str_subset_name("a_to")

trafo <-
  getParameters(g,x) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

  
p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()


# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)


cat("out\n")
(p*p_pert)(pars)
getParameters(p)

(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

times <- seq(0,400, length.out = 100)
(x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
  plotPrediction(
scales = "fixed"
)

# build dMod.frame
myframe <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))
  
```


```{r}

jac <- f %>% as.eqnvec %>% jacobianSymb(f$states)

jac_fun <- funC0(jac)


# Get the steady state of the system
steady_state <- (xs*p*p_pert)(c(0,Inf),pars, conditions = "Ctr", deriv = F) %>% .[[1]] %>% .[,-1] %>% unlist()
inpars <- p(pars) %>% .[[1]] %>% unclass() %>% {attr(., "deriv") <- NULL;.} %>%   {out <- .; out[names(steady_state)] <- steady_state; out}


M <- diag(2, nrow = length(f$states))
M[1,] <- -str_detect(f$states, "x")
M[3,] <- -str_detect(f$states, "y")
M[5,] <- -str_detect(f$states, "z")
M[M==2] <- 1

states_prime <- f$states %>% str_replace_all(structure(paste0(letters[24:26], "tot"), names = paste0("\\b", letters[24:26], "1\\b")))


jac_num <- do.call(jac_fun, as.list(inpars)) %>% matrix(nrow = length(f$states)) %>% signif(2)



(- diag(diag(1/(svdinv(M)%*%jac_num%*%M))) %*% svdinv(M)%*%jac_num %*% M) %>% 
  magrittr::set_colnames(states_prime) %>% 
  magrittr::set_rownames(f$states)





```






# 3x3 Matrices analysis for Mathematica

```{r}
letters[1:9] %>% 
  
  str_replace_all(c("\\b([adg])\\b" = "\\1 + alpha * \\1_1")) %>% 
  str_replace_all(c("\\b([beh])\\b" = "\\1 + beta * \\1_1")) %>% 

  matrix(nrow = 3) %>% 


  print_mathematica.matrix() %>% 
  {.}
```


```{r}
f <- read.csv("modelJapanese.csv") %>% 
  .[-(20:22),] %>% select(-Cz2x1) %>% as.data.frame() %>%  
  as.eqnlist()

f$rates <-
  f$rates %>%
    str_replace("\\* ?\\(.*", "") %>% # Optionally for Mathematica: kill regulatory feedback
    str_replace("v([0-9]*) *\\* *([x-z][12]).*", "k\\1 * \\2))") %>%  # Optionally for Mathematica: replace intrinsic Michaelis Menten activation by Mass Action activation
    {.}

model <- f %>% odemodel()

xs <- Xs_steady(model)
x <- Xs(model)
g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), f, compile = TRUE, modelname = "obs", attach.input = FALSE)

pinner <- list(
  # MA model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	.1	,
k2         	=	.01	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	.01	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	.01	,

kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

# kzx1_1     	=	c(0, 
#                 0.01)	,
# kzx1_2     	=	0.4	,
# kzx1_3     	=	0.05	,

kzx1       	=	0.05	,
kzx2       	=	0.4	,
kzx        	=	0.01	,


kzy1       	=	0.01	,
kzy2       	=	0.4	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)

pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log
pars_opt <- pars %>% str_subset_name("a_to")

trafo <-
  getParameters(g,x) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

  
p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()


# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)


cat("out\n")
(p*p_pert)(pars)
getParameters(p)

(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

times <- seq(0,400, length.out = 100)
(x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
  plotPrediction(
scales = "fixed"
)

# build dMod.frame
myframe <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))
```

```{r}
whichParOpt <- names(pars_opt)[c(1,4)]
perturbation_prediction <- (xs*p*p_pert)(c(0,Inf), pars, deriv = F)

r0 <- R_fun(pars_opt = pars_opt,
            perturbation_prediction = perturbation_prediction,
            obs_fun = g,
            p_fun = (p*p_pert),
            pars = pars) %>% local_response_matrix_eq10()

rkept <- r_kept_fun(pars_opt = pars_opt[whichParOpt],
                                        perturbation_prediction = perturbation_prediction, 
                                        obs_fun = g,
                                        p_fun = (p * p_pert), 
                                        pars = pars,
                                        alpha = 
                                   -log(.Machine$double.eps)) %>% 
  {.} %T>% print %>%
  {.}
myfits <- mstrust(obj_alpha, 
                        center =  structure(rep(0, length(whichParOpt)), names = whichParOpt), 
                        studyname = "Fits", 
                        cores = 3, 
                        fits = 12, 
                        sd = 1, 
                        mypars = pars, 
                        perturbation_prediction = perturbation_prediction, 
                        r_kept = rkept, 
                        p_fun = (p * p_pert),
                        obs_fun = g)
myfits %>% as.parframe()

profile(obj_alpha,myfits %>% as.parframe() %>% as.parvec(), whichParOpt,
        mypars = pars, 
        perturbation_prediction = perturbation_prediction, 
        r_kept = rkept, 
        p_fun = (p * p_pert),
        obs_fun = g)  


R_fun(myfits %>% as.parframe() %>% as.parvec(), perturbation_prediction, g, (p*p_pert), pars) %>% local_response_matrix_eq10() %>% round(2)
```



```{r}
# 
pred <- (xs*p*p_pert)(c(0,Inf), pars, deriv = T)
# pred %>% getDerivs()
states <- f$states

cat("Global responses\n")

R_full <- conveniencefunctions::extract_derivs(pred, states, states) %>%
  .[[1]] %>%
  .[-1] %>%
  matrix(ncol = 3) %>%

  
  # {out <- .; map(1:3, function(i) out[,i]/out[i,i])} %>%
  # do.call(cbind,.) %>%

  round(2) %>% 
  
  # sign %>% 
  magrittr::set_rownames(states) %>%
  magrittr::set_colnames(paste0(letters[24:26], "1")) %>% 
  
  {.} %T>% print %>%
  {.}
```



```{r}
(-R_full[6,2]*R_full[2,3]+R_full[2,2]*R_full[6,3])/
  (R_full[6,2]*R_full[7,3]-R_full[7,2]*R_full[6,3])
```

```{r}
log(.75888)

ana_pars_opt <- c(
  a_tox_Cx2y1	= log(.75888)	, # 1
  a_toy_Cy2z1	=	-2)	  # 2 

R_fun(ana_pars_opt, perturbation_prediction, g, (p*p_pert), pars) %>% local_response_matrix_eq10() %>% round(2)

diag(c(-20.17/.1287, 14.42/(-.1147), 22.29/(-.1146)))%*%R_fun(ana_pars_opt-40, perturbation_prediction, g, (p*p_pert), pars) # stimmt bis auf Rundungsfehler mit den integrierten sensitivitäten überein

diag(c(-20.17/.1287, 14.42/(-.1147), 22.29/(-.1146)))%*%R_fun(ana_pars_opt+40, perturbation_prediction, g, (p*p_pert), pars) # stimmt bis auf Rundungsfehler mit den integrierten sensitivitäten überein

```













