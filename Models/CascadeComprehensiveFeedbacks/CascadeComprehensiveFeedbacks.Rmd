---
title: "Enzymatic Cascade"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---


```{r setup, results='hide', echo=FALSE, message=FALSE}
# Load libraries and define some useful paths
# rm(list = ls())
library(MRAr)
library(scales)
library(xtable)
```


# Setup Model 

Careful, it might be broken due to the new comple Cx1z2 in the model...

## Prediction function
odemodel() writes the function f as a C-function, which is called by x and xs.
```{r, results='asis'}
f     <- "model.csv" %>% read.csv %>% as.eqnlist

# If the odemodel has been calculated already, it can be loaded with "load".
# If not, uncomment the next two lines.
# myodemodel <- odemodel(f, modelname = "cascade_comprehensive")
# saveRDS(myodemodel, "odemodel.rds")
myodemodel <- readRDS("odemodel.rds")

# Prediction function for continuous times
# x() is a function of time and parameters
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
# print(f, pander= T)
```


## Observation function
Observation function which returns our communicating species. 
The free parameters a_ij are introduced here to perform the linear combination of states which we wish to observe.
We chose to call them pars_opt, since they will be used to optimize the objective function later on.
```{r Most general observation function}
modules <- modules0 <- c("X","Y", "Z")

mypars_opt <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("x2y1","y2z1","z2x1", "z2x2", "z2y2", "y2x2"), paste0)) %>% matrix(nrow=3)

mypars_opt[c(2,3, 
             4,6, 
             8,
             11,
             13,
             18)] <- "0"

mycomplexes <- matrix(paste0("C", c("x2y1","y2z1","z2x1", "z2x2", "z2y2", "y2x2")), ncol = 1)

# samepars_opt <- paste0("a_", outer(rep("C",3), c("xy","yz","x1z", "x2z"), paste0)) %>% matrix(ncol=4)
# samepars_opt[c(3,4,8,11)] <- "0"

obs <- obs0 <- paste(c("x2", "y2", "z2"), "+", prodSymb(mypars_opt, mycomplexes)
                     # , "+", prodSymb(samepars_opt, mycomplexes)
                     )

g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), f, compile = TRUE, modelname = "obs", attach.input = FALSE)
```

Fluxes
```{r}
fluxes <- f %>% 
  as.data.frame() %>%
  {structure(.$Rate, names = .$Description %>% str_replace_all(" ", "_"))} %>% 
  # names %>%
  .[c(1:14)]

```



# Parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}
pinner <- list(
  # old model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	100	,
v1         	=	5	,
k2         	=	100	,
v2         	=	c(5,
                5)	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	100	,
v5         	=	5	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	100	,
v8         	=	1	,

k9         	=	100	,
k10        	=	100	,
gainuf     	=	1	,
gainlf     	=	1	,

# new complexes
kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

kzx1_1     	=	c(0, 
                0.01)	,
kzx1_2     	=	0.4	,
kzx1       	=	0.05	,

kzx        	=	0.01	,
kzx2       	=	0.4	,
kzx1_3     	=	0.05	,

kzy1       	=	0.01	,
kzy2       	=	0.4	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)

pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log

trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 


pars_opt <- pars %>% str_subset_name("a_to")


p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()

```



# Simulate perturbation data

For the perturbation experiments we use another parameter transformation to scale some parameters.
p_pert_fun automatically generates a parameter transformation function, which returns different sets of parameters for different conditions and a control condition.
Eg. if we have pars_perturbed = c("logx1" = log(0.9)), p_pert_fun(pars_perturbed) will return a parameter transformation with the control condition with unchanged parameters and one condition in which logx' = logx + log(0.9)

"log(0.9)" corresponds to a ~10% reduction of the original parameter value.
```{r}
# Which pars shall be perturbed?
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))

# pars_perturbed
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)


times <- seq(0,1000, length.out = 100)
(x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
  plotPrediction(
scales = "fixed"
)

# plotFluxes(pars, (x*p*p_pert), times, fluxes, conditions = "Ctr")
# ggplotly()

```


# Apply the algorithm
Play with the algorithm a bit

## Complexes Cx2y1, Cy2z1, Cz2x2 considered (activation and long feedback)
In r_kept_fun, different alphas lead to r21 and r32 being kept in the procedure as well. This is weird, but I should probably consider that I didn't include all complexes yet. 
However, funnily, for r1(-.3), r21 is kept in the optimization, but the complex which changes most is Cx2y1.
```{r}
perturbation_prediction <- (xs*p*p_pert)(c(0,Inf), pars, deriv = F)

r_0 <-   R_fun(pars_opt = pars_opt,
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r_0%>% round(2)

# pars_opt %>% print_r.named_vector()
which_pars_opt <- pars_opt[c(1,5,9)] %>% names



lapply(c(-.5, -.3, 0), function(i) {
  
  # which_pars_opt <- c("loga_Cxy", "loga_Cyz")
r_kept <- r_kept_fun(pars_opt = pars_opt[which_pars_opt],
                       perturbation_prediction = perturbation_prediction, 
                       obs_fun = g,
                       p_fun = (p * p_pert), 
                       pars = pars,
                       alpha = 
                       # -log(.Machine$double.eps) - .5
                       # -log(.Machine$double.eps) - .3
                       -log(.Machine$double.eps) + i
                     )
r_kept %>% print

mypars_opt <- which_pars_opt %>% are_names_of(0)
# obj_alpha(mypars_opt,
#           fixed = NULL,
#           perturbation_prediction = perturbation_prediction,
#           r_kept = r_kept,
#           obs_fun = g, 
#           p_fun = (p * p_pert), 
#           mypars = pars)


myfits <- mstrust(obj_alpha, 
                  center =  structure(rep(0, length(which_pars_opt)), names = which_pars_opt), 
                  studyname = "Fits", 
                  cores = 3, 
                  fits = 3, 
                  sd = 1, 
                  mypars = pars, 
                  perturbation_prediction = perturbation_prediction, 
                  r_kept = r_kept, 
                  p_fun = (p * p_pert),
                  obs_fun = g)

r_alpha_fun(pars_opt = myfits %>% as.parframe() %>% as.parvec() %>% unclass() , 
            pars = pars, 
            perturbation_prediction = perturbation_prediction,
            p_fun = (p*p_pert)
            ) %>% round(2) %>% print


myfits %>% as.parframe() %>% as.matrix() %>% print

NULL  
  
  
})

```


## Complexes Cx2y1, Cy2z1, Cz2x2 considered (activation and long feedback)
In r_kept_fun, different alphas lead to r21 and r32 being kept in the procedure as well. This is weird, but I should probably consider that I didn't include all complexes yet. 
However, funnily, for r1(-.3), r21 is kept in the optimization, but the complex which changes most is Cx2y1.
```{r}
perturbation_prediction <- (xs*p*p_pert)(c(0,Inf), pars, deriv = F)

r_0 <-   R_fun(pars_opt = pars_opt,
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r_0%>% round(2)

# pars_opt %>% print_r.named_vector()
which_pars_opt <- pars_opt[c(1,5,7,9,10)] %>% names

```

```{r}

lapply(c(-.5, -.3, 0), function(i) {
  
  # which_pars_opt <- c("loga_Cxy", "loga_Cyz")
r_kept <- r_kept_fun(pars_opt = pars_opt[which_pars_opt],
                       perturbation_prediction = perturbation_prediction, 
                       obs_fun = g,
                       p_fun = (p * p_pert), 
                       pars = pars,
                       alpha = 
                       # -log(.Machine$double.eps) - .5
                       # -log(.Machine$double.eps) - .3
                       -log(.Machine$double.eps) + i
                     )
r_kept %>% print

mypars_opt <- which_pars_opt %>% are_names_of(0)
# obj_alpha(mypars_opt,
#           fixed = NULL,
#           perturbation_prediction = perturbation_prediction,
#           r_kept = r_kept,
#           obs_fun = g, 
#           p_fun = (p * p_pert), 
#           mypars = pars)


myfits <- mstrust(obj_alpha, 
                  center =  structure(rep(0, length(which_pars_opt)), names = which_pars_opt), 
                  studyname = "Fits", 
                  cores = 3, 
                  fits = 3, 
                  sd = 1, 
                  mypars = pars, 
                  perturbation_prediction = perturbation_prediction, 
                  r_kept = r_kept, 
                  p_fun = (p * p_pert),
                  obs_fun = g)

r_alpha_fun(pars_opt = myfits %>% as.parframe() %>% as.parvec() %>% unclass() , 
            pars = pars, 
            perturbation_prediction = perturbation_prediction,
            p_fun = (p*p_pert)
            ) %>% round(2) %>% print


myfits %>% as.parframe() %>% as.matrix() %>% print

NULL  
  
  
})

```

# Description of results using the gadget 

I built this Shiny Gadget to explore the app
```{r}
source('../../gadget.R', echo=TRUE)
ropt_gadget(pars_opt %>% names)
```

Using this App, I can quickly scan through some parameter combinations and alpha-scan ranges

Combinations


* a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------
    * First, r23, then r31, then r12 are tuned in and the optimization has no problems. 
    * Then, r21 and r32 are included which is kind of strange. 
      However, they are not optimized away, at least. 
      But this comes at the cost, that also r31 and r23 not optimized away.

* a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, a_toz_Cz2y2
    * All complexes are added to the module which corresponds to the enzyme in the respective case
    * First, r12, r23 and r31 are tuned in.
    * Then, r21 is included (x to y), but this object can't be optimized away. 
      However, then also r23 is not optimized away.
    * Then, r32 is included, which again leads to r31 not being able to be optimized away.
    * Basically, this behavior is the same as with only the three complexes

* a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, -----------
    * Exactly the same behaviour as the setting before
    

* a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, a_toz_Cz2y2
    * All complexes are added to the module which corresponds to the enzyme in the respective case
    * First, r12 and r23 are tuned in, then r31. This is all normal, but doesn't include the short feedbacks yet
    * Then, r32 is included (y to z), but this object can't be optimized away. 
      This means, that there is some retroactivity detected on the short feedback, but it can't win against the activation
    * Then, when alpha is increased, r31 and r32 start vanishing again.










