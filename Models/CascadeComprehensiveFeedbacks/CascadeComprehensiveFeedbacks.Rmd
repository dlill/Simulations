---
title: "Enzymatic Cascade"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---


```{r setup, results='hide', echo=FALSE, message=FALSE}
# Load libraries and define some useful paths
# rm(list = ls())
library(MRAr)
library(scales)
library(xtable)
```


# Setup Model 

Careful, it might be broken due to the new comple Cx1z2 in the model...

## Prediction function
odemodel() writes the function f as a C-function, which is called by x and xs.
```{r, results='asis'}
f     <- "model.csv" %>% read.csv %>% as.eqnlist

# If the odemodel has been calculated already, it can be loaded with "load".
# If not, uncomment the next two lines.
# myodemodel <- odemodel(f, modelname = "cascade_comprehensive")
# saveRDS(myodemodel, "odemodel.rds")
myodemodel <- readRDS("odemodel.rds")

# Prediction function for continuous times
# x() is a function of time and parameters
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
# print(f, pander= T)
```


## Observation function
Observation function which returns our communicating species. 
The free parameters a_ij are introduced here to perform the linear combination of states which we wish to observe.
We chose to call them pars_opt, since they will be used to optimize the objective function later on.
```{r Most general observation function}
modules <- modules0 <- c("X","Y", "Z")

mypars_opt <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("x2y1","y2z1","z2x1", "z2x2", "z2y2", "y2x2"), paste0)) %>% matrix(nrow=3)

mypars_opt[c(2,3, 
             4,6, 
             8,
             11,
             13,
             18)] <- "0"

mycomplexes <- matrix(paste0("C", c("x2y1","y2z1","z2x1", "z2x2", "z2y2", "y2x2")), ncol = 1)

# samepars_opt <- paste0("a_", outer(rep("C",3), c("xy","yz","x1z", "x2z"), paste0)) %>% matrix(ncol=4)
# samepars_opt[c(3,4,8,11)] <- "0"

obs <- obs0 <- paste(c("x2", "y2", "z2"), "+", prodSymb(mypars_opt, mycomplexes)
                     # , "+", prodSymb(samepars_opt, mycomplexes)
                     )

g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), f, compile = TRUE, modelname = "obs", attach.input = FALSE)
```

Fluxes
```{r}
fluxes <- f %>% 
  as.data.frame() %>%
  {structure(.$Rate, names = .$Description %>% str_replace_all(" ", "_"))} %>% 
  # names %>%
  .[c(1:14)]

```


# Apply the algorithm interactively

## Parameter set 1

The first parameter set doesn't include the positive feedback from z to x. 
However, all other complexes are about equally strong.
```{r, message=FALSE}
pinner <- list(
  # old model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	100	,
v1         	=	5	,
k2         	=	100	,
v2         	=	c(5,
                5)	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	100	,
v5         	=	5	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	100	,
v8         	=	1	,

k9         	=	100	,
k10        	=	100	,
gainuf     	=	1	,
gainlf     	=	1	,

# new complexes
kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

kzx1_1     	=	c(0, 
                0.01)	,
kzx1_2     	=	0.4	,
kzx1       	=	0.05	,

kzx        	=	0.01	,
kzx2       	=	0.4	,
kzx1_3     	=	0.05	,

kzy1       	=	0.01	,
kzy2       	=	0.4	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)

trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()

pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log
pars_opt <- pars %>% str_subset_name("a_to")

# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)


cat("bla\n")
(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

# times <- seq(0,1000, length.out = 100)
# (x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
#   plotPrediction(
# scales = "fixed"
# )

# plotFluxes(pars, (x*p*p_pert), times, fluxes, conditions = "Ctr")
# ggplotly()


# build dMod.frame
myframe <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))

```

### Results of the interactive exploration

Start an interactive interface, where you can choose alpha-values and the optimization parameters
```{r}
source('../../gadget.R', echo=TRUE)
ropt_gadget(pars_opt %>% names)
```

Combinations

1. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------
    + r_0 has the correct signs, except of course for the retroactive connection r31, which should be zero but isn't
    - The first element to be tuned in, however, is the element r23. Therefore, the retroactive connection from z to y is stronger than the direct feedback. This element can also be optimized away.
    + The second element is r31 and it is correctly optimized away.
    - Then, r12 is tuned into the optimization, which is similar to r23. It is also optimized away. 
    + At higher alpha, r21 and r32 are kept in the optimization, indicating some retroactivity between x <-> y and y <-> z.
        - However, the optimized matrix is bullshit: r31 reappears, same as r23, but with wrong sign.
    * Summary: Activatory connections win and are not optimized away, short feedbacks can be detected even without including the corresponding complexes, but are not optimized away.
    
2. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, a_toz_Cz2y2
    * Basically, this behavior is the same as with only the three complexes

3. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, -----------
    * Basically, the same behaviour as the setting before
    
4. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, a_toz_Cz2y2
    + First, r12 and r23 are tuned in, then r31. This is all normal, but doesn't include the short feedbacks yet
    + Then, r32 is included (y to z), but this object can't be optimized away. 
      This means, that there is some retroactivity detected on the short feedback, but it can't win against the activation
    - Then, when alpha is increased, r31 and r32 start vanishing again. This means: "No retroactivity on the connection z to y" and than "z to x" is also retroactivity free
    + However, except for the retroactive connection r31, all the signs are correct.

5. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2
    * Qualitatively similar behaviour as in the first three settings

6. a_tox_Cx2y1, -----------, -----------, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2
    * Only element r31 is kept and also optimized away, all other connections have the correct sign



## Parameter set 2

This parameter set decreases the intrinsic deactivation of x2 and y2 in comparison to parameter set 1. 
Furthermore, the complex Cz2y2 association rate kzy1 is increased while the dissociation rate kzy2 is decreased, 
  such that there is more sequestration in this complex.
```{r, message=FALSE}
pinner <- list(
  # old model
x1         	=	100	,
y1         	=	100	,
z1         	=	100	,

k1         	=	100	,
v1         	=	5	,
k2         	=	100	,
v2         	=	.5	,

k31        	=	0.01	,
k32        	=	0.4	,
k4         	=	0.05	,

k5         	=	100	,
v5         	=	.5	,

k61        	=	0.05	,
k62        	=	0.4	,
k7         	=	0.01	,

k8         	=	100	,
v8         	=	1	,

k9         	=	100	,
k10        	=	100	,
gainuf     	=	1	,
gainlf     	=	1	,

# new complexes
kyx1      	=	0.05	,
kyx2       	=	0.4	,
kyx3       	=	0.01	,

kzx1_1     	=	0	,
kzx1_2     	=	0.4	,
kzx1       	=	0.05	,

kzx        	=	0.01	,
kzx2       	=	0.4	,
kzx1_3     	=	0.05	,

kzy1       	=	0.04	,
kzy2       	=	0.2	,
kzy3       	=	0.05	,

a_tox_Cx2y1	=	.Machine$double.eps	,
a_tox_Cz2x1	=	.Machine$double.eps	,
a_tox_Cz2x2	=	.Machine$double.eps	,
a_tox_Cy2x2	=	.Machine$double.eps	,
a_toy_Cy2z1	=	.Machine$double.eps	,
a_toy_Cz2y2	=	.Machine$double.eps	,
a_toy_Cy2x2	=	.Machine$double.eps	,
a_toz_Cz2x1	=	.Machine$double.eps	,
a_toz_Cz2x2	=	.Machine$double.eps	,
a_toz_Cz2y2	=	.Machine$double.eps 
) %>% 
 map_dbl(1)


pars <- c(pinner[1:3], str_subset_name(pinner, "a_to")) %>% log
pars_opt <- pars %>% str_subset_name("a_to")


trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^[^ak]*[xyz]2")) %>% 
  insert("x~value", x = names(pinner)[!names(pinner)%in%names(pars)], value = pinner[!names(pinner)%in%names(pars)]) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

p <- trafo %>% 
  # insert("x~log(x)", x = getSymbols(mytrafo[[i]]) %>% str_subset("^a_to")) %>% 
  P()


# generate functions for the different experimental conditions
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.9), "y1" = log(0.9), "z1" = log(0.9))
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

compile(p, p_pert, output = "Cascade_trafos")
loadDLL((g*x*p*p_pert), xs)

cat("bla\n")
(xs*p*p_pert)(c(0,Inf), pars, deriv = F) %>% do.call(rbind,.)

# times <- seq(0,1000, length.out = 100)
# (x*p*p_pert)(times = times, pars = pars, deriv = F) %>%
#   plotPrediction(
# scales = "fixed"
# )

# plotFluxes(pars, (x*p*p_pert), times, fluxes, conditions = "Ctr")
# ggplotly()


# build dMod.frame
myframe2 <- dMod.frame("1", g,x, p, data = NULL, e = NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars), times = list(times))

```

### Results of the interactive exploration

Start an interactive interface, where you can choose alpha-values and the optimization parameters
```{r}
source('../../gadget.R', echo=TRUE)
pars_to_check <- pars_opt %>% names %>% str_subset_not("Cz2x1")
ropt_gadget(pars_to_check, myframe2)
```

Combinations

1. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------
    - Around alpha = -.748, the matrices seem to have difficulties to be calculated during the optimization, maybe there is a problem with the inversion? (Looks like columns 1 and 2 are nearly parallel in the optimized matrix.)
    - At alpha = -.748, r31 and r32 are kept in the optimization, but this is really weird: r32 is y -> z activation. Also the optimized result is weird: r12 is positive even though it should be a negative feedback.  Also, r13 is positive, but this should also be a negative feedback.
    
2. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, a_toz_Cz2y2

3. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, -----------

4. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, a_toy_Cy2x2, a_toz_Cz2y2
    - First element is r12 (alpha ~ -.634) . 
        -Some of the pars_opt are definitely not identifiable, because the results change a lot, when I let it fit different times. (click left or right arrows after using the slider to incearse/decrease slider values by 0.001, which doesn't change r_kept, but restarts the optimization)
        - Indeed, even r21 sometimes flips its sign or sometimes is as large as 40 which points to a non-identifiability.
    - Then r31 comes into play (alpha ~-.468), same problem with non-identifiable parameters, but at least the matrices are similar
    - Then, r13 is added, but this can't be optimized away, neither is r12 then, but instead r21 is optimized away. Furthermore r23 has a positive sign which it shouldn't have
        - Often, the optimization doesn't work, some parameters are pushed to +/- Inf. Maybe try using a prior around zero? 
    - Later, r31 vanishes from the optimization again and only the top row is kept (r12 and r13). Results are weird, since the transposed elements are minimized somehow? (14_04 o'clock)
    
    
5. a_tox_Cx2y1, a_toy_Cy2z1, a_toz_Cz2x2, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2

6. a_tox_Cx2y1, -----------, -----------, -----------, -----------, a_tox_Cy2x2, a_toy_Cz2y2



