---
title: "Hub model"
author: "Daniel Lill"
output: html
---

# Load libraries and define some useful paths
```{r setup, message=FALSE}
library(parallel)
library(MRAr)
library(xtable)
```

# Model setup

## ODE model setup
```{r Prediction function Cascade, results='asis'}
reactions <- NULL %>% 
  addReaction(from = "x1", to = "x2", rate = "((v1 *  x1)/(k1 + x1))", description = "act_x") %>% 
  addReaction(from = "x2", to = "x1", rate = "((v2 * x2 )/(k2 + x2))", description = "deact_x") %>% 
  addReaction(from = "x2 + y1", to = "Cx2y1", rate = "(k31 * y1 *x2)  - (k32 *Cx2y1)", description = "x2_y_to_comp") %>% 
  addReaction(from = "Cx2y1", to = "x2 + y2", rate = "(k4 * Cx2y1)", description = "y2_formation") %>% 
  addReaction(from = "y2", to = "y1", rate = "((v5 * y2)/(k5 + y2))", description = "deact_y") %>% 
  addReaction(from = "x2 + z1", to = "Cx2z1", rate = "(k61 * z1 *x2) -  (k62 *Cx2z1)", description = "x2_z_to_comp") %>% 
  addReaction(from = "Cx2z1", to = "x2 + z2", rate = "(k7 * Cx2z1)", description = "z2_formation") %>% 
  addReaction(from = "z2", to = "z1", rate = "((v8 * z2)/(k8 + z2))", description = "deact_z") 

compiled_model <- odemodel(reactions, modelname = "Hub", estimate = c("x1", "k1"))

# Prediction function
x <- Xs(odemodel = compiled_model) 
# Prediction function for steady states
xs <- Xs_steady(compiled_model) 
```

## Observation function
Observation function which returns our communicating species. 
The free parameters a_ij are introduced here to perform the linear combination of states which we wish to observe.
```{r Observation function with Cx2z2 in x-module}
modules <- c("X", "Y", "Z")

observables <-  c("x2 + a_Cxy * Cx2y1 + a_Cxz * Cx2z1 + a_tox_Cxy * Cx2y1 + a_tox_Cxz * Cx2z1",
          "y2 + a_Cxy * Cx2y1 + a_toy_Cxz * Cx2z1",
          "z2 + a_Cxz * Cx2z1 + a_toz_Cxy * Cx2y1 ")
g <-   Y(as.eqnvec(structure(observables, names = modules)), x, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```

### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
The way to implement is this, is
log_pars %>% p_log %>% p_other %>% p_other_2 %>% ...
```{r}
trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = str_subset(.currentSymbols, "^C*[xyz](2|1.2)")) %>% # set inits to zero
  insert("x~exp(x)", x = .currentSymbols) %>%
  # {.} %T>% print %>% 
  {.} 

p_log <- P(trafo = trafo,
           modelname = "p_log",
           compile = T)
```

# These pars are in SI 22
```{r Parameters which imbalance the effects of y and z}
pars <- c(
x1       	=	100	, # 1
y1       	=	100	, # 4
z1       	=	100	, # 7

k1       	=	100	, # 9
v1       	=	1.5	, # 10
k2       	=	100	, # 11
v2       	=	1	, # 12
k31      	=	0.01	, # 13
k32      	=	0.4	, # 14
k4       	=	0.05	, # 15
k5       	=	100	, # 16
v5       	=	5	, # 17
k61      	=	0.05	, # 18
k62      	=	0.4	, # 19
k7       	=	0.05	, # 20
k8       	=	100	, # 21
v8       	=	5	, # 22

a_Cxy      	=	.Machine$double.eps	, # 23
a_Cxz      	=	.Machine$double.eps	, # 24
a_tox_Cxy	=	.Machine$double.eps	, # 25
a_tox_Cxz	=	.Machine$double.eps	, # 26
a_toy_Cxz      	=	.Machine$double.eps	, # 27
a_toz_Cxy      	=	.Machine$double.eps	  # 28
) %>% log 
alpha_pars <- pars[str_detect(names(pars), "^a_")]
```


```{r}

# p_pert <- letters[24:26] %>% paste0("1") %>% are_names_of(log(0.9)) %>% p_pert_fun(pars = pars, modelname = NULL)
# model <- dMod.frame("1", g, x, p_log, NULL, NULL, p_pert = list(p_pert), pars = list(pars), xs = list(xs))
# ropt_gadget(c("a_tox_Cxy", "a_tox_Cxz"), model)
```


# Apply different perturbations and run the algorithm
Since all possible combinations of paramter perturbations are many, these computations are done in a parallelized manner on a remote server.
If you want to quickly check the implementation with only one perturbation per module, uncomment the lower three lines assigning "perturbations_module_*", if you want to check the full set of perturbations, uncomment the upper three lines
```{r}
perturbations_module_x <- c("x1", "k1", "v1", "k2", "v2")
perturbations_module_y <- c("y1", "k5", "v5", "k31", "k32", "k4")
perturbations_module_z <- c("z1", "k8", "v8", "k61", "k62", "k7")

# perturbations_module_x <- c("x1")
# perturbations_module_y <- c("y1")
# perturbations_module_z <- c("z1")

perturbation_combinations <- expand.grid(perturbations_module_x, perturbations_module_y, perturbations_module_z, stringsAsFactors = F) 

perturbations <- map(1:nrow(perturbation_combinations), function(i) {
  mynames <- perturbation_combinations[i,] %>% unlist() %>% unname() %>% unique()
  if(length(mynames)<3) return(NULL)
  mynames %>% are_names_of(log(0.9))
}) %>% 
  .[!map_lgl(., is.null)]


myrunbg_job <- runbg({
  cores <- detectFreeCores()
  # alphas <- c(-3, -2, -1, 0, 1, 2, 3)
  # perturbations<-perturbations[1:2]
  alphas <- seq(-3,3,0.5)
  dose_pars <- pars[1]
  alpha_par_settings <- list(upstream = c("a_tox_Cxy", "a_tox_Cxz"),
       both = c("a_Cxy", "a_Cxz"))

    results <- run_different_perturbations(dose_pars = dose_pars, 
                              pars0 = pars, 
                              alpha_pars = alpha_pars,
                              alphas = alphas, 
                              perturbations = perturbations,
                              xs = xs,
                              p_log = p_log,
                              p_pert = p_pert,
                              g = g, 
                              cores = cores,
                              alpha_par_settings = alpha_par_settings)
    results 
}, machine = c("fermi"), input = ls(pos=.GlobalEnv), filename = "2018_09_24_hub"
, recover = T
)
```

Check if results are ready. Uncomment if needed
```{r}
myrunbg_job$check()
```

Fetch/save/restore results. Comment out the first two lines after saving the fetched fit results.
```{r}
myrunbg <- myrunbg_job$get()[[1]]
saveRDS(myrunbg, file = "2018_09_24_hubresult.rds")
results <- readRDS("2018_09_24_hubresult.rds")

```

Purge files from the remote computing job.  Uncomment if needed
```{r}
# myrunbg_job$purge()
```

```{r}
results <- results %>% 
  as.tibble() %>% 
  # rowwise() %>% 
  # mutate(r_0 = list(unlist(r_0,F))) %>% 
  mutate(r_0 = map(r_0, ~.x[[1]]),
         pars_perturbed = map(pars_perturbed, ~.x[[1]]),
         alpha = unlist(alpha),
         dose_name = unlist(dose_name),
         dose_par = unlist(dose_par),
         upstream = map(algo_results, ~.x[[1]]),
         both = map(algo_results, ~.x[[2]])
         ) %>% 
  unnest(upstream) %>% 
  unnest(both)

```

```{r}
map(results, ~map_lgl(.x, function(i) inherits(i, "try-error")) %>% any)
```


# Explore results
```{r Prepare data for clustering}
results_unnested_matrices <-
  results %>%
  rename(upstreamropt = r_optupstream, 
         bothropt = r_optboth,
         upstreamrkept = r_keptupstream, 
         bothrkept = r_keptboth,
         rzero = r_0
         ) %>% 
  filter(map_lgl(upstreamropt, is.double), 
         map_lgl(bothropt, is.double),
         map_lgl(rzero, is.double)) %>% 
  mutate(upstreamropt = map(upstreamropt, matrix_2_wide_df, nm = (paste0("up_ropt", outer(1:3,1:3, paste0)))),
         bothropt = map(bothropt, . %>% matrix_2_wide_df(paste0("both_ropt", outer(1:3,1:3, paste0)))),
         upstreamrkept = map(upstreamrkept, matrix_2_wide_df, nm = (paste0("up_rkept", outer(1:3,1:3, paste0)))),
         bothrkept = map(bothrkept, . %>% matrix_2_wide_df(paste0("both_rkept", outer(1:3,1:3, paste0)))),
         rzero = map(rzero, . %>% matrix_2_wide_df(paste0("rzero_", outer(1:3,1:3, paste0)))),
         pars_perturbed = map(pars_perturbed, . %>% names %>% `names<-`(LETTERS[24:26]) %>% t %>% as.data.frame(stringsAsFactors = F)),
         perturbed_set = seq_along(alpha),
         alpha = as.numeric(alpha)) %>% 
  unnest(upstreamropt, bothropt,upstreamrkept, bothrkept, rzero, pars_perturbed)


```

```{r}
cluster_by_rzero <- cluster_matrices_and_print_perturbations(results_unnested_matrices, 0, "rzero_", 3, 1)
cluster_representative_r0_cl1 <- c("x1", "y1", "k8")
cluster_representative_r0_cl2 <- c("k1", "k5", "k8")
cluster_representative_r0_cl3 <- c("x1", "y1", "z1")
```

```{r}
cluster_by_ropt <- cluster_matrices_and_print_perturbations(results_unnested_matrices, 0, "up_ropt", 2, 1)
cluster_representative_by_ropt_cl1 <- c("x1", "y1", "z1")
cluster_representative_by_ropt_cl2 <- c("x1", "y1", "k8")
```

```{r}
cluster_by_rkept <- cluster_matrices_and_print_perturbations(results_unnested_matrices, 2, "up_rkept", 4, 10)

map(unique(results$alpha),~ cluster_matrices_and_print_perturbations(results_unnested_matrices, .x, "up_rkept", 4, 10)$.cluster)
```

```{r}
get_r0_r1_ropt_rkept <- function(results, a, pp) {
  myresults <- filter(results, alpha == a, map_lgl(pars_perturbed, . %>% names %>% identical(pp)))
  list(perturbed_parameters = t(pp), 
       r_0 = myresults$r_0[[1]], 
       r_1 =  myresults$r_1upstream[[1]] %>% round(2), 
       r_opt = myresults$r_optupstream[[1]] %>% round(2), 
       r_kept = myresults$r_keptupstream[[1]])
}
```



```{r}
alpha <- -3
get_r0_r1_ropt_rkept(results, alpha, cluster_representative_r0_cl1) %>%
  imap(~.x %>% {cbind(c(.y, rep("", nrow(.x)-1)), .)}) #%>%
  # print2word_matrixlist("matrices_cluster1")
get_r0_r1_ropt_rkept(results, alpha, cluster_representative_r0_cl2) %>%
  imap(~.x %>% {cbind(c(.y, rep("", nrow(.x)-1)), .)}) #%>%
  # print2word_matrixlist("matrices_cluster2")
get_r0_r1_ropt_rkept(results, alpha, cluster_representative_r0_cl3) %>% 
  imap(~.x %>% {cbind(c(.y, rep("", nrow(.x)-1)), .)}) #%>%
  # print2word_matrixlist("matrices_cluster3")
```


# Description of results
```{r}
# helper functions/objects for exporting to ms word
communicating_species <- paste0(LETTERS[24:26],"*")
```

Export some tables for the publication
```{r}
# results %>% 
#   filter(alpha == 0) %>% 
#   filter(map_lgl(pars_perturbed, . %>% {str_detect(names(.), c("x1", "y1", "z1"))} %>% all)) %>% 
#   .[c("r_opt","r_opt1")] %>%
#   unlist(F) %>% #.[t(matrix(1:6, nrow = 3))] %>% 
#   {mymatrix <- .; `names<-`(mymatrix, names(mymatrix) %>% str_replace_all(c("1$" = "gl = -10", "2$" = "gl = 0", "3$" = "gl = 2",
#                                                "r_0" = "a = 0, ", "r_1" = "a = 1, ", "r_opt" = "a = a_opt, ")))} %>%
#   imap(~ .x  %>% round(2) %>% as.tibble() %>% `names<-`(communicating_species) %>% bind_cols(aopt = rep(.y ,3), module = communicating_species,.) ) %>% 
#   print_msword_table("matrices")

```


## Clean up Workdir
```{r}
unlink(paste0("*.", c("c", "o", "so", "tex", "lnk")))
unlink("Fits/", T)
unlink(".pars_controlled/", T)
```
