---
title: "Cascade - regulatory feedback"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---

# Load libraries and define some useful paths
```{r setup, results='hide', echo=FALSE, message=FALSE}
library(xtable)
library(parallel)
library(MRAr)
```

# Model setup

## ODE model setup
```{r Prediction function Cascade, results='asis'}
reactions <- NULL %>% 
  addReaction(from = "x1", to = "x2", rate = "((v1 *  x1)/(k1 + x1))*(1 + u1*z2/k9)/(1 + z2/k9)", description = "act_x") %>% 
  addReaction(from = "x2", to = "x1", rate = "((v2 * x2 )/(k2 + x2))", description = "deact_x") %>% 
  addReaction(from = "x2 + y1", to = "Cx2y1", rate = "(k31 * y1 *x2) * (1 + u2*z2/k10)/(1 + z2/k10) - (k32 *Cx2y1)", description = "x2_y_to_comp") %>% 
  addReaction(from = "Cx2y1", to = "x2 + y2", rate = "(k4 * Cx2y1)", description = "y2_formation") %>% 
  addReaction(from = "y2", to = "y1", rate = "((v5 * y2)/(k5 + y2))", description = "deact_y") %>% 
  addReaction(from = "y2 + z1", to = "Cy2z1", rate = "((k61 *z1 *y2) - (k62 * Cy2z1))", description = "y2_z_to_comp") %>% 
  addReaction(from = "Cy2z1", to = "y2 + z2", rate = "(k7 * Cy2z1)", description = "z2_formation") %>% 
  addReaction(from = "z2", to = "z1", rate = "((v8 * z2)/(k8 + z2))", description = "z_deact") %>% 
  addReaction(from = "x2 + z2", to = "Cx2z2", rate = "k111*x2*z2-k112*Cx2z2", description = "z2_x2_to_comp") %>% 
  addReaction(from = "Cx2z2", to = "x1 + z2", rate = "k12*Cx2z2", description = "deact_x_by_z2") 

compiled_model <- odemodel(reactions, modelname = "Cascade", estimate = c("x1", "k1"))

# Prediction function
x <- Xs(odemodel = compiled_model) 
# Prediction function for steady states
xs <- Xs_steady(compiled_model) # When computing steady states, set deriv = F
```

### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.

```{r Most general observation function}
modules <-  c("X", "Y", "Z")

alpha_parameters <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
alpha_parameters[c(3,4,8)] <- "0"

complexes <- matrix(c("Cx2y1", "Cy2z1", "Cx2z2"), ncol = 1)

alpha_parameters_to_both_modules <- paste0("a_", outer(rep("C",3), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
alpha_parameters_to_both_modules[c(3,4,8)] <- "0"

observables <- paste(c("x2", "y2", "z2"), "+", prodSymb(alpha_parameters, complexes), "+", prodSymb(alpha_parameters_to_both_modules, complexes))


g <- Y(g = as.eqnvec(structure(observables, names = modules)), 
       f = reactions, 
       compile = TRUE, 
       modelname = "obsfn0", 
       attach.input = FALSE)
```



### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
```{r}
trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = str_subset(.currentSymbols, "^C*[xyz](2|1.2)")) %>% # set inits to zero
  insert("x~0", x = c("k111", "k112", "k12")) %>% 
  insert("x~exp(x)", x = .currentSymbols) %>%
  # {.} %T>% print %>% 
  {.} 

p_log <- P(trafo = trafo,
           modelname = "p_log",
           compile = T)
```


```{r}
pars <- c(
  a_Cxy    	=	.Machine$double.eps	, # 1
  a_Cyz    	=	.Machine$double.eps	, # 2
  a_Czx    	=	.Machine$double.eps	, # 3
  a_tox_Cxy	=	.Machine$double.eps	, # 4
  a_tox_Czx	=	.Machine$double.eps	, # 5
  a_toy_Cxy	=	.Machine$double.eps	, # 6
  a_toy_Cyz	=	.Machine$double.eps	, # 7
  a_toz_Cyz	=	.Machine$double.eps	, # 8
  a_toz_Czx	=	.Machine$double.eps	, # 9
  
  u1   	    =	1	, # 10
  u2   	    =	1	, # 11
  k9       	=	50	, # 29
  k10      	=	50	, # 13
  
  k1       	=	100	, # 12
  v1       	=	1.5	, # 30
  k2       	=	100	, # 20
  v2       	=	1	, # 31
  
  k31      	=	0.002	, # 21
  k32      	=	0.4	, # 22
  k4       	=	0.05	, # 23
  k5       	=	100	, # 24
  v5       	=	5	, # 32
  
  k61      	=	0.005	, # 25
  k62      	=	0.4	, # 26
  k7       	=	0.05	, # 27
  k8       	=	100	, # 28
  v8       	=	1	, # 33
  
  
  x1       	=	100	, # 34
  y1       	=	100	, # 35
  z1       	=	100	  # 36 
) %>% 
  log

alpha_pars <- pars[str_detect(names(pars), "^a_")]
```




# Apply different perturbations and run the algorithm
Since all possible combinations of paramter perturbations are many, these computations are done in a parallelized manner on a remote server.
If you want to quickly check the implementation with only one perturbation per module, uncomment the lower three lines assigning "perturbations_module_*", if you want to check the full set of perturbations, uncomment the upper three lines
```{r}
perturbations_module_x <- c("x1", "k1", "v1", "k2", "v2")
perturbations_module_y <- c("y1", "k5", "v5", "k31", "k32", "k4")
perturbations_module_z <- c("z1", "k8", "v8", "k61", "k62", "k7")

# perturbations_module_x <- c("x1")
# perturbations_module_y <- c("y1")
# perturbations_module_z <- c("z1")

perturbation_combinations <- expand.grid(perturbations_module_x, perturbations_module_y, perturbations_module_z, stringsAsFactors = F) 

perturbations <- map(1:nrow(perturbation_combinations), function(i) {
  mynames <- perturbation_combinations[i,] %>% unlist() %>% unname() %>% unique()
  if(length(mynames)<3) return(NULL)
  mynames %>% are_names_of(log(0.9))
}) %>% 
  .[!map_lgl(., is.null)]


myrunbg_job <- runbg({
  cores <- detectFreeCores()
  pars0 <- pars
  
  u2s <- c(-3, -1, -0.5, -0.3, -0.1, 0, 0.1, 0.3, 0.5, 1, 3)
  map(u2s, function(u2) {
    pars <- pars0
    pars["u2"] <- c(u2 = u2)
    
    alphas <- c(-3, -1, 0, 1, 3)
    map(alphas, function(alpha) {
      
      mclapply(perturbations, function(perturbations_module_) {
        p_pert <- p_pert_fun(perturbations_module_, pars = pars, modelname = NULL)
        
        perturbation_prediction <- (xs*p_log*p_pert)(c(0,Inf), pars, deriv = F)
        
        try({r_0 <- R_fun(pars_opt = alpha_pars,
                          perturbation_prediction = perturbation_prediction,
                          obs_fun = g,
                          p_fun = (p_log*p_pert),
                          pars = pars) %>% local_response_matrix_eq10()})
        if(inherits(r_0, "try-error")) return(NULL)
        
        algo <- function(which_alpha_pars, prefix = NULL) {
          
          out <- tibble(r_kept = list(NULL), parframes = list(NULL), r_opt = list(NULL))
          
          r_kept <- r_kept_fun(pars_opt = alpha_pars[which_alpha_pars],
                               perturbation_prediction = perturbation_prediction,
                               obs_fun = g,
                               p_fun = (p_log * p_pert),
                               pars = pars,
                               alpha = -log(.Machine$double.eps) + alpha)
          out$r_kept <- list(r_kept)
          
          myfits <- mstrust(obj_alpha,
                            center =  structure(rep(0, length(which_alpha_pars)), names = which_alpha_pars),
                            studyname = "Fits",
                            cores = 1,
                            fits = 3,
                            sd = 1,
                            mypars = pars,
                            perturbation_prediction = perturbation_prediction,
                            r_kept = r_kept,
                            p_fun = (p_log * p_pert),
                            obs_fun = g)
          myparframe <- try(myfits %>% as.parframe())
          out$parframes <- list(myparframe)
          if (inherits(myparframe, "try-error")) {
            out$parframes <- list(myfits)
            return(out)
          }
          
          r_opt <- r_alpha_fun(pars_opt = myfits %>% as.parframe() %>% as.parvec() %>% unclass() ,
                               pars = pars,
                               perturbation_prediction = perturbation_prediction,
                               p_fun = (p_log*p_pert),
                               obs_fun = g)
          out$r_opt <- list(r_opt)
          return(out)
        }
        
        to_upstream_module <- algo(c("a_tox_Cxy", "a_toy_Cyz", "a_toz_Czx"), "upstream")
        to_both_modules <- algo(c("a_Cxy", "a_Cyz", "a_Czx"), "both")
        
        bind_cols(tibble(r_0 = list(r_0 %>% round(2)), pars_perturbed = list(perturbations_module_), alpha = alpha, u2 = u2), to_upstream_module, to_both_modules)
      }, mc.cores = cores) %>% 
        do.call(rbind,.) 
    }) %>% 
      do.call(rbind,.)
  }) %>% 
    do.call(rbind,.)
  
}, machine = c("knecht4"), input = ls(pos=.GlobalEnv), filename = "2018_07_18_33_10_u1"
, recover = T
)
```

Check if results are ready.
```{r}
myrunbg_job$check()
```

Fetch/save/restore results
```{r}
# myrunbg <- myrunbg_job$get()[[1]]
# saveRDS(myrunbg, file = "2018_07_18_33_10_u2myrunbg.rds")
results <- readRDS("2018_07_18_33_10_u2myrunbg.rds")
```

Purge files from the remote computing job.
```{r}
# myrunbg_job$purge()
```


# Description of results
```{r}
# helper functions/objects for exporting to ms word
communicating_species <- paste0(LETTERS[24:26],"*")
```

Export some tables for the publication
```{r}
results %>% 
  filter(alpha == 0, u2 %in% c(-10,0,2)) %>% 
  filter(map_lgl(pars_perturbed, . %>% {str_detect(names(.), c("x1", "y1", "z1"))} %>% all)) %>% 
  .[c("r_opt","r_opt1")] %>%
  unlist(F) %>% #.[t(matrix(1:6, nrow = 3))] %>% 
  {mymatrix <- .; `names<-`(mymatrix, names(mymatrix) %>% str_replace_all(c("1$" = "gl = -10", "2$" = "gl = 0", "3$" = "gl = 2",
                                               "r_0" = "a = 0, ", "r_1" = "a = 1, ", "r_opt" = "a = a_opt, ")))} %>%
  imap(~ .x  %>% round(2) %>% as.tibble() %>% `names<-`(communicating_species) %>% bind_cols(aopt = rep(.y ,3), module = communicating_species,.) ) %>% print2word_matrixlist("matrices_u2_positive_detected")


results %>% 
  filter(alpha == 0, u2 %in% c(-10,0,2)) %>% 
  filter(map_lgl(pars_perturbed,. %>% {str_detect(names(.), c("x1", "y1", "k8"))} %>% all)) %>% 
  .[c("r_opt","r_opt1")] %>%
  unlist(F) %>% #.[t(matrix(1:6, nrow = 3))] %>% 
  {mymatrix <- .; `names<-`(mymatrix, names(mymatrix) %>% str_replace_all(c("1$" = "gl = -10", "2$" = "gl = 0", "3$" = "gl = 2",
                                               "r_0" = "a = 0, ", "r_1" = "a = 1, ", "r_opt" = "a = a_opt, ")))} %>%
  imap(~ .x  %>% round(2) %>% as.tibble() %>% `names<-`(communicating_species) %>% bind_cols(aopt = rep(.y ,3), module = communicating_species,.) ) %>% print2word_matrixlist("matrices_u2_negative_detected")

```



## Clean up Workdir
```{r}
unlink(paste0("*.", c("c", "o", "so", "tex", "lnk")))
unlink("Fits/", T)
unlink(".pars_controlled/", T)
```

