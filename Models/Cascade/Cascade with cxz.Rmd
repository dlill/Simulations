---
title: "Cascade - x2z2 mass action feedback"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---

# Load libraries and define some useful paths

```{r setup, results='hide', echo=FALSE, message=FALSE}
rm(list = ls())
library(MRAr)
library(scales)
library(xtable)
library(parallel)
path <- paste0(getwd(), "/")
pathout <- paste0(path, "Output/")
```

# Cascade

## Setup Model 
This is the setup of the ODE model.

### Prediction function
odemodel writes a C-function, which is executed in x and xs.
x is a regular prediction function while xs only finds and returns the steady states.
If the odemodel has been calculated already, it can be loaded with "load".
```{r Prediction function Cascade, results='asis'}
modelname   <- "Cascade"
mymodel     <- as.eqnlist(read.csv(paste0( modelname, ".csv")))

# myodemodel <- odemodel(mymodel, modelname = paste0(modelname), deriv = T)
# save(myodemodel, file = paste0( "odemodel",modelname, ".RData"))
load(paste0( "odemodel",modelname, ".RData"))

# Prediction function
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
loadDLL(x)
# print(mymodel)
# mymodel %>% as.eqnvec() %>% print(pander = T)
# myodemodel[[1]] %>% attr("eq")
```






### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.


```{r Observation function with Cx2z2 in x-module}
# modules <- modules0 <- c("x2","y2", "z2")
# 
# obs <- obs0 <- c("x2+a_1*Cx2y1",
#           "y2+a_2*Cy2z1",
#           "z2+a_3*Cx2z2")
# g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```


```{r Most general observation function}
modules <- modules0 <- c("X","Y", "Z")

mypars_opt <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
mypars_opt[c(3,4,8)] <- "0"


mycomplexes <- matrix(c("Cx2y1", "Cy2z1", "Cx2z2"), ncol = 1)

samepars_opt <- paste0("a_", outer(rep("C",3), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
samepars_opt[c(3,4,8)] <- "0"

obs <- obs0 <- paste(c("x2", "y2", "z2"), "+", prodSymb(mypars_opt, mycomplexes), "+", prodSymb(samepars_opt, mycomplexes))


g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)

```


### Inner parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}
pars_raw <- read.csv(paste0( "pars.csv"), header = FALSE)  # dynamical parameters
pars_raw <- structure(pars_raw$V2, names = as.character(pars_raw$V1))
ic_raw <- read.csv(paste0( "IC.csv"), header = F)          # initial conditions
ic_raw <- structure(ic_raw$V2, names = as.character(ic_raw$V1))
# sort ics like they appear in x, so it can be used in stode()
vars_x <- attr(x, "parameters")[attr(x, "parameters") %in% names(ic_raw)]
ic_raw <- ic_raw[vars_x]

pars_inner_opt_0 <- setdiff(attr(g, "parameters"),names(c(pars_raw,ic_raw)))
pars_inner_opt_0 <- structure(rep(0, length(pars_inner_opt_0)), 
                              names = pars_inner_opt_0)

pars_inner_0 <- pars_inner <- c(ic_raw, pars_raw, pars_inner_opt_0)
```


### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
The way to implement is this, is
log_pars %>% p_log %>% p_other %>% p_other_2 %>% ...
```{r}
trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("deg|syn")) %>% # set synthesis and degradations to zero
  insert("x~0", x = getSymbols(mytrafo[[i]]) %>% str_subset("^C*[xyz](2|1.2)")) %>% # set inits to zero
  insert("x~0", x = c("k131", "k132", "k14")) %>% 
  insert("x~exp(x)", x = getSymbols(mytrafo[[i]])) %>%
  # {.} %T>% print %>% 
  {.} 

p_log <- P(trafo = trafo,
           modelname = "p_log",
           compile = T)

pars <- getParameters(p_log) %>% are_names_of(0) %>% sort_by_name()
pars_opt <- names(pars_inner_opt_0) %>% are_names_of(.Machine$double.eps) %>% log
```


```{r}
pars <- c(
a_Cxy    	=	.Machine$double.eps	, # 1
a_Cyz    	=	.Machine$double.eps	, # 2
a_Czx    	=	.Machine$double.eps	, # 3
a_tox_Cxy	=	.Machine$double.eps	, # 4
a_tox_Czx	=	.Machine$double.eps	, # 5
a_toy_Cxy	=	.Machine$double.eps	, # 6
a_toy_Cyz	=	.Machine$double.eps	, # 7
a_toz_Cyz	=	.Machine$double.eps	, # 8
a_toz_Czx	=	.Machine$double.eps	, # 9

gainlf   	=	1	, # 10
gainuf   	=	1	, # 11
k9       	=	100	, # 29
k10      	=	100	, # 13

k1       	=	100	, # 12
v1       	=	1.5	, # 30
k2       	=	100	, # 20
v2       	=	1	, # 31

k31      	=	0.002	, # 21
k32      	=	0.4	, # 22
k4       	=	0.05	, # 23
k5       	=	100	, # 24
v5       	=	5	, # 32

k61      	=	0.005	, # 25
k62      	=	0.4	, # 26
k7       	=	0.05	, # 27
k8       	=	100	, # 28
v8       	=	1	, # 33

k111     	=	0.002	, # 14
k112     	=	0.4	, # 15
k12      	=	0.05	, # 16

x1       	=	100	, # 34
y1       	=	100	, # 35
z1       	=	100	  # 36 
) %>% 
  log

```




# Apply different perturbations
```{r}
pp_x <- c("x1", "k1", "v1", "k2", "v2", "k111", "k112", "k12") 
pp_y <- c("y1", "k5", "v5", "k31", "k32", "k4") 
pp_z <- c("z1", "k8", "v8", "k61", "k62", "k7", "k111", "k112", "k12")

mygrid <- expand.grid(pp_x, pp_y, pp_z, stringsAsFactors = F) 
pp_list <- map(1:nrow(mygrid), function(i) {
  mynames <- mygrid[i,] %>% unlist() %>% unname() %>% unique()
  if(length(mynames)<3) return(NULL)
  mynames %>% are_names_of(log(0.9))
}) %>% 
  .[!map_lgl(., is.null)]
alpha <- 0

myrunbg_job <- runbg({
  cores <- detectFreeCores()
  result <- mclapply(pp_list, function(pp) {
    p_pert <- p_pert_fun(pp, pars = pars, modelname = NULL)

    myframe <- dMod.frame("1", g, x, p_log, NULL, NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars))

    g <- myframe$g[[1]]
    p_pert <- myframe$p_pert[[1]]
    p <- myframe$p[[1]]
    xs <- myframe$xs[[1]]
    pars <- myframe$pars[[1]]

    # browser()
    perturbation_prediction <- (xs*p*p_pert)(c(0,Inf), pars, deriv = F)

    try({r0 <- R_fun(pars_opt = pars_opt,
                     perturbation_prediction = perturbation_prediction,
                     obs_fun = g,
                     p_fun = (p*p_pert),
                     pars = pars) %>% local_response_matrix_eq10()})
    if(inherits(r0, "try-error")) return(NULL)

    algo <- function(which_pars_opt, prefix = NULL) {
      rkept <- r_kept_fun(pars_opt = pars_opt[which_pars_opt],
                          perturbation_prediction = perturbation_prediction,
                          obs_fun = g,
                          p_fun = (p * p_pert),
                          pars = pars,
                          alpha =
                            -log(.Machine$double.eps) + alpha)
      myfits <- mstrust(obj_alpha,
                        center =  structure(rep(0, length(which_pars_opt)), names = which_pars_opt),
                        studyname = "Fits",
                        cores = 3,
                        fits = 3,
                        sd = 1,
                        mypars = pars,
                        perturbation_prediction = perturbation_prediction,
                        r_kept = rkept,
                        p_fun = (p * p_pert),
                        obs_fun = g)

      try(myfits %>% as.parframe()) %>%
      {e <- .; if (inherits(e, "try-error")) return(NULL)}


      ropt <- r_alpha_fun(pars_opt = myfits %>% as.parframe() %>% as.parvec() %>% unclass() ,
                          pars = pars,
                          perturbation_prediction = perturbation_prediction,
                          p_fun = (p*p_pert))

      out <- list(rkept, myfits %>% as.parframe,ropt %>% round(2))
      names(out) <- paste0(prefix, "r_kept", "parframes", "ropt")
      return(out)
    }

    to_upstream_module <- algo(c("a_tox_Cxy", "a_toy_Cyz", "a_toz_Czx"), "upstream")
    to_both_modules <- algo(c("a_Cxy", "a_Cyz", "a_Czx"), "both")

    out <- c(list(r0 = r0 %>% round(2)), to_upstream_module, to_both_modules)

  }, mc.cores = cores)
  result
}, machine = c("fermi"), input = ls(pos=.GlobalEnv), filename = "2018_07_17_16_10_myrunbg_job"
  # , recover = T
)
# myrunbg_job$check()
# runbg(wait_for_runbg(myrunbg_job), filename = "wait", input = "myrunbg_job")
myrunbg <- myrunbg_job$get()$fermi
saveRDS(myrunbg, file = "myrunbg.rds")
results <- readRDS("myrunbg.rds")
# myrunbg_job$purge()

# saveRDS(results, "test_different_perturbations.rds")
```



```{r Debug, eval=FALSE}
pp <- pp_list[[1]]
result <- map(pp_list[1], function(pp) {
    p_pert <- p_pert_fun(pp, pars = pars, modelname = NULL)

    myframe <- dMod.frame("1", g, x, p_log, NULL, NULL, p_pert = list(p_pert), xs = list(xs), pars = list(pars))

    g <- myframe$g[[1]]
    p_pert <- myframe$p_pert[[1]]
    p <- myframe$p[[1]]
    xs <- myframe$xs[[1]]
    pars <- myframe$pars[[1]]

    # browser()
    perturbation_prediction <- (xs*p*p_pert)(c(0,Inf), pars, deriv = F)

    try({r0 <- R_fun(pars_opt = pars_opt,
                     perturbation_prediction = perturbation_prediction,
                     obs_fun = g,
                     p_fun = (p*p_pert),
                     pars = pars) %>% local_response_matrix_eq10()})
    if(inherits(r0, "try-error")) return(NULL)

    algo <- function(which_pars_opt, prefix = NULL) {
      rkept <- r_kept_fun(pars_opt = pars_opt[which_pars_opt],
                          perturbation_prediction = perturbation_prediction,
                          obs_fun = g,
                          p_fun = (p * p_pert),
                          pars = pars,
                          alpha =
                            -log(.Machine$double.eps) + alpha)
      myfits <- mstrust(obj_alpha,
                        center =  structure(rep(0, length(which_pars_opt)), names = which_pars_opt),
                        studyname = "Fits",
                        cores = 3,
                        fits = 3,
                        sd = 1,
                        mypars = pars,
                        perturbation_prediction = perturbation_prediction,
                        r_kept = rkept,
                        p_fun = (p * p_pert),
                        obs_fun = g)

      try(myfits %>% as.parframe()) %>%
      {e <- .; if (inherits(e, "try-error")) return(NULL)}


      ropt <- r_alpha_fun(pars_opt = myfits %>% as.parframe() %>% as.parvec() %>% unclass() ,
                          pars = pars,
                          perturbation_prediction = perturbation_prediction,
                          p_fun = (p*p_pert))

      out <- list(rkept, myfits %>% as.parframe,ropt %>% round(2))
      names(out) <- paste0(prefix, "r_kept", "parframes", "ropt")
      return(out)
    }

    to_upstream_module <- algo(which_pars_opt = c("a_tox_Cxy", "a_toy_Cyz", "a_toz_Czx"), "upstream")
    to_both_modules <- algo(which_pars_opt = c("a_Cxy", "a_Cyz", "a_Czx"), "both")

    out <- c(list(r0 = r0 %>% round(2)), to_upstream_module, to_both_modules)

  })
```


```{r analyse results}
# results %>% str1

ropt_upstream <- results %>% map(5) 

mygrid_2 <-
  pp_list %>% map(names) %>% 
  do.call(rbind,.) %>% 
  as.tibble() %>% 
  cbind(., ind = 1:nrow(.)) %>% 
  filter(!str_detect(V1, "(k3)|(k4)")) %>% 
  filter(!str_detect(V2, "(k6)|(k7)")) %>% 
  filter(str_detect(V2,"5")) %>% 
  {.}

map(mygrid_2$ind, function(i) {
  not_equal_to_conc_perturbation <- map_lgl(1:9, function(j) !near(ropt_upstream[[i]][j], ropt_upstream[[1]][j], tol = 0.02)) %>% sum()
  
  # if(not_equal_to_conc_perturbation == 0) return(NULL)
  print(c(i, not_equal_to_conc_perturbation))
  pp_list[[i]] %>% names %>% print
  print(ropt_upstream[[i]])
})
```


## Show the code
### Perturb modules
Now the module can be simulated to generate perturbation data.

### Parameter trafos for convenient perturbation data
Just to show the code...
Set up the perturbations
```{r}
# Which pars shall be perturbed?
pars_perturbed_0 <- pars_perturbed <- c("x1" = log(0.8), "y1" = log(0.8), "z1" = log(0.8))

p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)
# ```
# 
# 
# ```{r  which pars are perturbed  Cascade, echo=FALSE}
# pars <- c(100,0,0,100,0,0,100,0,0,
#           14.766,0.241,1058.451,5.295,
#           0.003,
#           0.012,0.022,
#           1150.484,
#           50,
#           0.00065,
#           0.005,0.023,
#           550.208,13.304,50,50,
#           1,1,
#           0,0,0,0,0,0,00,0,0,0,0,0,
#           rep(0, length(pars_opt_0))) # large complex
print("")
pars <- c(100,0,0,100,0,0,100,0,0,
          100,1.5,100,1,     0.002,0.4,0.05,
          100,5,            0.005,0.4,0.05,
          100,1,
          100,100,1,1,
          0,0,0,0,0,0,0,0,0,
          0.002,0.4,0.05,
          rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0))

pars

pars_0 <- pars <- log(pars+.Machine$double.eps) %>% set_names(names(pars_0))# large complex concentrations
# p_log(pars)

# (p_log*p_pert)(pars)

perturbation_prediction_0 <- perturbation_prediction <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars, deriv = F)

# mytime <- 2000
# (x*p_log*p_pert)(times = seq(0,2000, length.out = 50), pars = pars) %>% 
#   getDerivs() %>% 
#   extract2(1) %>%
#   apply_expression({x[,c(str_detect(colnames(x), "(Cx2y1\\.)|time"))]}) %>% prdlist() %>% set_names("blas") %>% 
#   plotPrediction()



# perturbation_prediction %>% lapply(round,2)

r_kept_0 <- r_kept_fun(pars_opt = pars_opt_0,
                       perturbation_prediction = perturbation_prediction, 
                       obs_fun = g,
                       p_fun = (p_log * p_pert), 
                       pars = pars,
                       alpha = -log(0+.Machine$double.eps))
r_kept_0

r_0 <-   R_fun(pars_opt = pars_opt[c("loga_tox_Cxy", "loga_toy_Cyz")],
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p_log*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r_0%>% round(2)

r_1 <-   R_fun(pars_opt = pars_opt[c("loga_tox_Cxy", "loga_toy_Cyz")]-(log(0+.Machine$double.eps)),
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p_log*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r_1 %>% round(2)

par_opt_names <- c("loga_tox_Cxy", "loga_toy_Cyz", "loga_toz_Czx")
# matrix(c(F,F,F,T,F,F,F,T,F), ncol = 3)
myfits <- mstrust(obj_alpha, center =  structure(rep(0, length(pars_opt_0[par_opt_names])), names = names(pars_opt_0[par_opt_names])), studyname = "Fits", cores = 3, fits = 3, sd = 1, mypars = pars, perturbation_prediction = perturbation_prediction_0, r_kept = r_kept_0)
# myfits %>% as.parframe() 
best_fit <- myfits %>% as.parframe() %>% as.parvec()

r_alpha_fun(pars_opt = unclass(best_fit), pars = pars, perturbation_prediction = perturbation_prediction) %>% round(2)
```




# Prepare pars for SI

```{r}
SI_pars <- c(100,0,0,100,0,0,100,0,0,
          14,0.24,1000,5,0.006,0.012,0.022,
          1150,22,0.001,0.005,0.023,
          550,13.3,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,rep(0, length(pars_opt_0))) # large complex concentrations

SI_pars2 <- c(100,0,0,100,0,0,100,0,0,
          66,0.45,620,2.4,0.001,0.02,0.4,
          500,22,0.0002,0.035,0.092,
          900,10,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,rep(0, length(pars_opt_0))) # lower
names(SI_pars2) <- names(SI_pars) <- names(pars_inner)

# plot((x)(seq(0,1000,length.out = 50), SI_pars2, deriv = F))


printSI_pars <- c(SI_pars[-c(2:3,5:6,8:9,28:36,40:48)],
               SI_pars2[-c(2:3,5:6,8:9,28:36,40:48)])
printnames <- names(SI_pars[-c(2:3,5:6,8:9,28:36,40:48)])

# printSI_pars %>% 
#   matrix(ncol=2) %>% 
#   set_rownames(printnames) %>% 
#   xtable %>% print() 

# P
```


# Dose response plots
```{r, eval=FALSE}
par_opt_names <- pars_opt_0 %>% names %>% sort

par_opt_settings <- list(par_opt_names[c(1,2,3)]
                         # ,
                         # par_opt_names[c(4,7,9)]
                         # ,
                         # par_opt_names[c(5,6,8)]
                         # ,
                         # par_opt_names[c(5:9)]
                         )
dr_list <- lapply(seq_along(par_opt_settings), function(i) {

  scan_grid(which_par = "logk111",
            dosages = sort(c(unique(seq(-16,0,by = 0.5)))),
            pars = pars,
            alpha_scan_range = c(-9,seq(-3,2,by = 0.1)),
            pars_opt = pars_opt_0[par_opt_settings[[i]]],
            grid_points_raw = c(-9,-3,0,2))

})
saveRDS(dr_list, file = "Output/dr_list single scan.rds")
dr_list2 <- lapply(seq_along(par_opt_settings), function(i) {
  scan_grid(which_par = "logk112",
            dosages = sort(unique(seq(-5,1,by = 0.2))),
            pars = pars,
            alpha_scan_range = c(-9,seq(-3,3,by = 0.1)),
            pars_opt = pars_opt_0[par_opt_settings[[i]]],
            grid_points_raw = c(-9,-3,0,3))
})
save(dr_list, file = "Output/wupwup")
dr_list3 <- lapply(seq_along(par_opt_settings), function(i) {
  scan_grid(which_par = "logk12",
            dosages = sort(unique(seq(-5,0,by = 0.2))),
            pars = pars,
            alpha_scan_range = c(-9,seq(-3,3,by = 0.1)),
            pars_opt = pars_opt_0[par_opt_settings[[i]]],
            grid_points_raw = c(-9,-3,0,3))
})

save(dr_list, dr_list2, dr_list3, file = "Output/20170808 dr_lists cxz single scans.RData")
# load("Output/20170725 dr_lists cxz.RData")

```



# General plotting functions
Plot as dos-response with alpha as facets
```{r Plot generation}
load("Output/20170725 dr_lists cxz.RData")
myplot <- c(dr_list, dr_list2, dr_list3) %>% 
  combine_dr_list() %>% 
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter(dose >= -8, dose <= 2.5) %>% 
  filter(par_opt_setting == 9) %>%
  filter(alpha %in% 0) %>%
  filter(matrix != "r_kept") %>%
  { .$matrix[.$matrix == "r_alpha"] <- "r(a_i = 1)"
    .$matrix[.$matrix == "r_opt"] <- "r(a = a_opt)"
    .$matrix <- .$matrix %>% factor(levels = c("r(a_i = 1)", "r(a = a_opt)", "r_kept"))
    .
  } %>% 
  mutate(Element = r_element) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = Element, linetype = Element)) +
  geom_line() +
  theme_dMod() +
  scale_color_dMod() +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  facet_grid(matrix~., scales = "free")+
  xlab("log(k12)")
plotly::ggplotly(myplot)
# myplot
# ggsave(plot = myplot,
       # filename = paste0("~/Promotion/Writing/Papers/2017 02 MRA optimization procedure Paper/pictures/plots/", "k12",".png"),
       # width = 10,
       # height = 10,
       # units = "cm",
       # device = "png")
```

# Print the matrices a = 0, a = 1, a = inf, a = a_opt
```{r}
modulnames <- c("X*", "Y*", "Z*")
verbatim <- function(chr) chr 

load("Output/20170725 dr_lists cxz.RData")
mydr <- c(dr_list, dr_list2, dr_list3) %>% 
  combine_dr_list() 
#a_0
r0 <- mydr %>% 
  filter(par_opt_setting ==9) %>% 
  filter(alpha == -3) %>%
  filter(dose ==-2) %>% 
  filter(matrix == "r_alpha") %>%
  select(r_element, value) %>% unique() %>% extract2(2) %>% 
  matrix(ncol = 3) %>% round(digits = 2) %>% signif(2) %>% 
  data.frame(c("", "$\\vec{a} = \\vec{a}_0$",""),modulnames,.) %>% 
  set_colnames(c("", "", modulnames)) %>% 
  set_rownames(NULL)
#a_1
r1 <- mydr %>% 
  filter(par_opt_setting ==9) %>% 
  filter(alpha == 1) %>%
  filter(dose ==-2) %>% 
  filter(matrix == "r_alpha") %>%
  select(r_element, value) %>% unique() %>% extract2(2) %>% 
  matrix(ncol = 3) %>% round(digits = 2) %>% signif(2) %>% 
  data.frame(c("\\hline \n", "$\\vec{a} = \\vec{a}_1$",""),modulnames,.) %>% 
  set_colnames(c("", "", modulnames)) %>% 
  set_rownames(NULL) 
# a_opt
ropt <- mydr %>% 
  filter(par_opt_setting ==9) %>% 
  filter(alpha == 1) %>%
  filter(dose ==-2) %>% 
  filter(matrix == "r_opt") %>%
  select(r_element, value) %>% unique() %>% extract2(2) %>% 
  matrix(ncol = 3) %>% round(digits = 2) %>% signif(2) %>% 
  data.frame(c("\\hline \n", "$\\vec{a} = \\vec{a}_{opt}$",""),modulnames,.) %>% 
  set_colnames(c("", "", modulnames)) %>% 
  set_rownames(NULL) 
rbind(r0,r1,ropt) %>% 
  xtable(align=c("r|c|c|rrr|")) %>% 
  print(sanitize.text.function = verbatim,
        include.rownames = F)

rbind(r0,r1,ropt)  %>% write_excel_csv(path = "~/Promotion/Writing/Papers/2017 02 MRA optimization procedure Paper/pictures/Figure6 matrices.csv")
```

























