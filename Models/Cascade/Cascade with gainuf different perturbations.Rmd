---
title: "Cascade - x2z2 mass action feedback"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---

# Load libraries and define some useful paths
```{r setup, results='hide', echo=FALSE, message=FALSE}
library(parallel)
library(MRAr)
library(xtable)
```

# Model setup

## ODE model setup
```{r Prediction function Cascade, results='asis'}
modelname   <- "Cascade"
reactions     <- as.eqnlist(read.csv(paste0(modelname, ".csv")))
myodemodel <- odemodel(reactions, modelname = modelname)

# Prediction function
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
loadDLL(x)
```

### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.

```{r Most general observation function}
modules <-  c("X","Y", "Z")

alpha_parameters <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
alpha_parameters[c(3,4,8)] <- "0"


complexes <- matrix(c("Cx2y1", "Cy2z1", "Cx2z2"), ncol = 1)

alpha_parameters_to_both_modules <- paste0("a_", outer(rep("C",3), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
alpha_parameters_to_both_modules[c(3,4,8)] <- "0"

observables <- paste(c("x2", "y2", "z2"), "+", prodSymb(alpha_parameters, complexes), "+", prodSymb(alpha_parameters_to_both_modules, complexes))


g <- Y(g = as.eqnvec(structure(observables, names = modules)), 
       f = reactions, 
       compile = TRUE, 
       modelname = "obsfn0", 
       attach.input = FALSE)

```



### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
The way to implement is this, is
log_pars %>% p_log %>% p_other %>% p_other_2 %>% ...
```{r}
trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = str_subset(.currentSymbols, "deg|syn")) %>% # set synthesis and degradations to zero
  insert("x~0", x = str_subset(.currentSymbols, "^C*[xyz](2|1.2)")) %>% # set inits to zero
  insert("x~0", x = c("k131", "k132", "k14")) %>% 
  insert("x~0", x = c("k111", "k112", "k12")) %>% 
  insert("x~exp(x)", x = .currentSymbols) %>%
  # {.} %T>% print %>% 
  {.} 

p_log <- P(trafo = trafo,
           modelname = "p_log",
           compile = T)
```


```{r}
pars <- c(
  a_Cxy    	=	.Machine$double.eps	, # 1
  a_Cyz    	=	.Machine$double.eps	, # 2
  a_Czx    	=	.Machine$double.eps	, # 3
  a_tox_Cxy	=	.Machine$double.eps	, # 4
  a_tox_Czx	=	.Machine$double.eps	, # 5
  a_toy_Cxy	=	.Machine$double.eps	, # 6
  a_toy_Cyz	=	.Machine$double.eps	, # 7
  a_toz_Cyz	=	.Machine$double.eps	, # 8
  a_toz_Czx	=	.Machine$double.eps	, # 9
  
  gainlf   	=	1	, # 10
  gainuf   	=	1	, # 11
  k9       	=	100	, # 29
  k10      	=	100	, # 13
  
  k1       	=	100	, # 12
  v1       	=	1.5	, # 30
  k2       	=	100	, # 20
  v2       	=	1	, # 31
  
  k31      	=	0.002	, # 21
  k32      	=	0.4	, # 22
  k4       	=	0.05	, # 23
  k5       	=	100	, # 24
  v5       	=	5	, # 32
  
  k61      	=	0.005	, # 25
  k62      	=	0.4	, # 26
  k7       	=	0.05	, # 27
  k8       	=	100	, # 28
  v8       	=	1	, # 33
  
  
  x1       	=	100	, # 34
  y1       	=	100	, # 35
  z1       	=	100	  # 36 
) %>% 
  log 

alpha_pars <- pars[str_detect(names(pars), "^a_")]
```




# Apply different perturbations and run the algorithm
Since all possible combinations of paramter perturbations are many, these computations are done in a parallelized manner on a remote server.
If you want to quickly check the implementation with only one perturbation per module, uncomment the lower three lines assigning "perturbations_module_*", if you want to check the full set of perturbations, uncomment the upper three lines
```{r}
perturbations_module_x <- c("x1", "k1", "v1", "k2", "v2")
perturbations_module_y <- c("y1", "k5", "v5", "k31", "k32", "k4")
perturbations_module_z <- c("z1", "k8", "v8", "k61", "k62", "k7")

# perturbations_module_x <- c("x1")
# perturbations_module_y <- c("y1")
# perturbations_module_z <- c("z1")

perturbation_combinations <- expand.grid(perturbations_module_x, perturbations_module_y, perturbations_module_z, stringsAsFactors = F) 

perturbations <- map(1:nrow(perturbation_combinations), function(i) {
  mynames <- perturbation_combinations[i,] %>% unlist() %>% unname() %>% unique()
  if(length(mynames)<3) return(NULL)
  mynames %>% are_names_of(log(0.9))
}) %>% 
  .[!map_lgl(., is.null)]


myrunbg_job <- runbg({
  cores <- detectFreeCores()
  pars0 <- pars
  
  gainufs <- c(-10, -1, -0.5, -0.4, -0.3, -0.2, -0.1, 0, 0.1, 0.2, 0.3, 0.4, 0.5, 1, 2, 5, 10)
  map(gainufs, function(gainuf) {
    pars <- pars0
    pars["gainuf"] <- c(gainuf = gainuf)
    
    alphas <- c(-3, -1, -0.5, 0, 1, 2, 3)
    map(alphas, function(alpha) {
      
      mclapply(perturbations, function(perturbations_module_) {
        p_pert <- p_pert_fun(perturbations_module_, pars = pars, modelname = NULL)
        
        perturbation_prediction <- (xs*p_log*p_pert)(c(0,Inf), pars, deriv = F)
        
        try({r_0 <- R_fun(pars_opt = alpha_pars,
                          perturbation_prediction = perturbation_prediction,
                          obs_fun = g,
                          p_fun = (p_log*p_pert),
                          pars = pars) %>% local_response_matrix_eq10()})
        if(inherits(r_0, "try-error")) return(NULL)
        
        algo <- function(which_alpha_pars, prefix = NULL) {
          
          out <- tibble(r_kept = list(NULL), parframes = list(NULL), r_opt = list(NULL))
          
          r_kept <- r_kept_fun(pars_opt = alpha_pars[which_alpha_pars],
                               perturbation_prediction = perturbation_prediction,
                               obs_fun = g,
                               p_fun = (p_log * p_pert),
                               pars = pars,
                               alpha =
                                 -log(.Machine$double.eps) + alpha)
          out$r_kept <- list(r_kept)
          
          myfits <- mstrust(obj_alpha,
                            center =  structure(rep(0, length(which_alpha_pars)), names = which_alpha_pars),
                            studyname = "Fits",
                            cores = 1,
                            fits = 5,
                            sd = 1,
                            mypars = pars,
                            perturbation_prediction = perturbation_prediction,
                            r_kept = r_kept,
                            p_fun = (p_log * p_pert),
                            obs_fun = g)
          myparframe <- try(myfits %>% as.parframe())
          out$parframes <- list(myparframe)
          if (inherits(myparframe, "try-error")) {
            out$parframes <- list(myfits)
            return(out)
          }
          
          r_opt <- r_alpha_fun(pars_opt = myfits %>% as.parframe() %>% as.parvec() %>% unclass() ,
                               pars = pars,
                               perturbation_prediction = perturbation_prediction,
                               p_fun = (p_log*p_pert))
          out$r_opt <- list(r_opt)
          return(out)
        }
        
        to_upstream_module <- algo(c("a_tox_Cxy", "a_toy_Cyz", "a_toz_Czx"), "upstream")
        to_both_modules <- algo(c("a_Cxy", "a_Cyz", "a_Czx"), "both")
        
        bind_cols(tibble(r_0 = list(r_0 %>% round(2)), pars_perturbed = list(perturbations_module_), alpha = alpha, gainuf = gainuf), to_upstream_module, to_both_modules)
      }, mc.cores = cores) %>% 
        do.call(rbind,.) 
    }) %>% 
      do.call(rbind,.)
  }) %>% 
    do.call(rbind,.)
  
}, machine = c("knecht4"), input = ls(pos=.GlobalEnv), filename = "2018_07_18_33_10_gainuf"
# , recover = T
)

```

Check if results are ready.
```{r}
myrunbg_job$check()
```

Fetch/save/restore results
```{r}
# myrunbg <- myrunbg_job$get()[[1]]
# saveRDS(myrunbg, file = "2018_07_18_33_10_gainufmyrunbg.rds")
results <- readRDS("2018_07_18_33_10_gainufmyrunbg.rds")

```

Purge files from the remote computing job.
```{r}
# myrunbg_job$purge()
```


```{r}
results3 <- readRDS("2018_07_18_33_10_gainufmyrunbg3.rds")
results2 <- readRDS("2018_07_18_33_10_gainufmyrunbg2.rds")
results <- readRDS("2018_07_18_33_10_gainufmyrunbg.rds")
results <- bind_rows(results, results2, results3)
# myrunbg_job$purge()

# saveRDS(results, "test_different_perturbations.rds")
```




# Description of results
```{r}
# helper functions/objects for exporting to ms word
communicating_species <- paste0(LETTERS[24:26],"*")
print_msword_table <- function(x, path, digits = 2) {
  tables <- map(x, . %>% xtable::xtable(digits = digits) %>% {xtable:::print.xtable(invisible(.), include.rownames = F)}) %>% 
    paste0(collapse = "\n\n")
  
  tables %>%
    paste("\\documentclass[10pt,a4paper]{article}
\\usepackage[latin1]{inputenc}
\\usepackage{amsmath}
\\usepackage{amsfonts}
\\usepackage{amssymb}
\\usepackage{graphicx}
\\begin{document}", ., "\\end{document}") %>%
    write_lines(paste0(path,".tex"))
  system2("pandoc", c(paste0("-o ",path,".docx"), paste0(path,".tex")))
  }

```

Export some tables for the publication
```{r}
results %>% 
  filter(alpha == 0, gainuf %in% c(-10,0,2)) %>% 
  filter(map_lgl(pars_perturbed, . %>% {str_detect(names(.), c("x1", "y1", "z1"))} %>% all)) %>% 
  .[c("r_opt","r_opt1")] %>%
  unlist(F) %>% #.[t(matrix(1:6, nrow = 3))] %>% 
  {mymatrix <- .; `names<-`(mymatrix, names(mymatrix) %>% str_replace_all(c("1$" = "gl = -10", "2$" = "gl = 0", "3$" = "gl = 2",
                                               "r_0" = "a = 0, ", "r_1" = "a = 1, ", "r_opt" = "a = a_opt, ")))} %>%
  imap(~ .x  %>% round(2) %>% as.tibble() %>% `names<-`(communicating_species) %>% bind_cols(aopt = rep(.y ,3), module = communicating_species,.) ) %>% print_msword_table("matrices_gainuf_positive_detected")


results %>% 
  filter(alpha == 0, gainuf %in% c(-10,0,2)) %>% 
  filter(map_lgl(pars_perturbed,. %>% {str_detect(names(.), c("x1", "y1", "k8"))} %>% all)) %>% 
  .[c("r_opt","r_opt1")] %>%
  unlist(F) %>% #.[t(matrix(1:6, nrow = 3))] %>% 
  {mymatrix <- .; `names<-`(mymatrix, names(mymatrix) %>% str_replace_all(c("1$" = "gl = -10", "2$" = "gl = 0", "3$" = "gl = 2",
                                               "r_0" = "a = 0, ", "r_1" = "a = 1, ", "r_opt" = "a = a_opt, ")))} %>%
  imap(~ .x  %>% round(2) %>% as.tibble() %>% `names<-`(communicating_species) %>% bind_cols(aopt = rep(.y ,3), module = communicating_species,.) ) %>% print_msword_table("matrices_gainuf_negative_detected")

```



```{r}
#' Print single matrices as matrices in word math environemt
#' 
#' The align argument of xtable outside of mypublish mat needs to be ncol(mat) + 1
#' @param x 
#' @param filename 
#'
#' @return
#' @export
#'
#' @examples
#' list(r_0 = r_0, r_1 = r_1, r_opt_1 = r_opt_1) %>% imap(~.x %>% round(2) %>% xtable(align = rep("",4)) %>% print(tabular.environment="pmatrix", include.colnames = F, include.rownames = F, floating = F, hline.after = NULL) %>%  mypublish_mat(.y)
mypublish_mat <- function(x,filename) {
  
  x %>%
    paste("\\documentclass[10pt,a4paper]{article}
\\usepackage[latin1]{inputenc}
\\usepackage{amsmath}
\\usepackage{amsfonts}
\\usepackage{amssymb}
\\usepackage{graphicx}
\\begin{document}", 
"\\begin{equation*}",
filename, " = ", .,
"\\end{equation*}", 
"\\end{document}") %>%
    write_lines(paste0(filename,".tex"))
  system2("pandoc", c(paste0("-o", filename,".docx"), paste0(filename,".tex")))}
  

results %>%
  filter(alpha == 0, gainuf %in% c(-1)) %>%
  .[c("r_opt", "r_opt1")] %>% unlist(F) %>%
 imap(~.x %>% round(2) %>% xtable(align = rep("",4)) %>% print(tabular.environment="pmatrix", include.colnames = F, include.rownames = F, floating = F, hline.after = NULL) %>%  mypublish_mat(.y))
```

