---
title: "MEK-ERK-Model"
author: "Daniel Lill"
output: 
  pdf_document:
    keep_tex: true
---

# Load libraries and define some useful paths

```{r setup, results='hide', echo=FALSE, message=FALSE}
library(MRAr)
library(scales)
library(xtable)
```

# Model Setup

## ODE model setup
```{r Prediction function}
reactions <- NULL %>% 
  addReaction(from = "m1", to = "m2", rate = "k1*m1", description = "act_m") %>% 
  addReaction(from = "m2", to = "m1", rate = "k2*m2", description = "deact_m") %>% 
  addReaction(from = "m2 + e1", to = "Cm2e1", rate = "(k31 * e1 *m2)", description = "m2_e1_to_comp") %>% 
  addReaction(from = "Cm2e1", to = "m2 + e1", rate = "(k32 *Cm2e1)", description = "comp_to_m2_e1") %>% 
  addReaction(from = "Cm2e1", to = "m2 + e2", rate = "(k4 * Cm2e1)", description = "e2_formation") %>% 
  addReaction(from = "e2 + p1", to = "Ce2p1", rate = "((k61 *p1 *e2))", description = "e2_p1_to_comp") %>% 
  addReaction(from = "Ce2p1", to = "e2 + p1", rate = "(k62 * Ce2p1)", description = "compt_to_e2_p1") %>% 
  addReaction(from = "Ce2p1", to = "e1 + p1", rate = "k5*Ce2p1", description = "e2_deact") %>% {.}

compiled_model <- odemodel(reactions, modelname = "Prabakaran", estimate = c("m1", "k1"))

# Prediction function
x <- Xs(odemodel = compiled_model)
# Prediction function for steady states
xs <- Xs_steady(compiled_model)
```


## Observation function
Observation function which returns our communicating species. 
The free parameters a_ij are introduced here to perform the linear combination of states which we wish to observe.
We chose to call them alpha_oars, since they will be used to optimize the objective function later on.
```{r Naive observation function}
modules <-  c("X","Y")
observables <-  c("m2+a_xy*Cm2e1+a_tox_xy*Cm2e1",
                 "e2+a_xy*Cm2e1+a_toy_xy*Cm2e1")
g <- Y(as.eqnvec(structure(observables, names = modules)), x, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```



## Parameter transformation function
```{r}
trafo <- getParameters(x,g) %>% 
  setNames(.,.) %>% 
  insert("x~0", x = str_subset(.currentSymbols, "^C*[me](2|1.2)")) %>% # set inits to zero
  insert("x~exp(x)", x = .currentSymbols) %>%
  # {.} %T>% print %>% 
  {.} 


p_log <- P(trafo = trafo,
           compile = T,
           modelname = "p_log")
```

```{r}
pars <- c(
  m1      	=	100	, # 1
  e1      	=	1000	, # 2
  p1      	=	100	, # 3
  k1      	=	0.1	, # 4
  k2      	=	0.1	, # 5
  k31     	=	0.01	, # 6
  k32     	=	1	, # 7
  k4      	=	1	, # 8
  k5      	=	1	, # 9
  k61     	=	1	, # 10
  k62     	=	0.01	, # 11
  a_xy    	=	.Machine$double.eps	, # 12
  a_tox_xy	=	.Machine$double.eps	, # 13
  a_toy_xy	=	.Machine$double.eps	  # 14 
) %>% 
  log

alpha_pars <- pars[str_detect(names(pars), "^a_")]
```

# Simulate perturbation data

For the perturbation experiments we use another parameter transformation to scale some parameters.
p_pert_fun automatically generates a parameter transformation function, which returns different sets of parameters for different conditions and a control condition.
Eg. if we have pars_perturbed = c("logx1" = log(0.9)), p_pert_fun(pars_perturbed) will return a parameter transformation with the control condition with unchanged parameters and one condition in which logx' = logx + log(0.9)

"log(0.9)" corresponds to a ~10% reduction of the original parameter value.
```{r which pars are perturbed}
# Which pars shall be perturbed?
pars_perturbed <- c(k1 = log(0.9), e1 = log(0.9))

p_pert <- p_pert_fun(pars_perturbed = pars_perturbed,
                     pars = pars)
```



## Generate the perturbation data and run the algorithm
```{r}
perturbation_prediction <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars, deriv = F)
r_kept <- r_kept_fun(pars_opt = alpha_pars, 
                     perturbation_prediction = perturbation_prediction,
                     obs_fun = g, 
                     p_fun = (p_log*p_pert),
                     pars = pars)
# r_kept <- c(F,F,T,F)

# perturbation_prediction <-  (xs*p_pert)(times = c(0,Inf), pars = pars, deriv = F)

r <-   R_fun(pars_opt = alpha_pars[c("loga_tox_xy")],
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p_log*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r%>% round(3)

myfits <- mstrust(obj_alpha,
                  center = alpha_pars["a_tox_xy"] * 0 ,
                  studyname = "Fits",
                  cores = 3,
                  fits = 3,
                  sd = 3, 
                  r_kept = r_kept,
                  mypars = pars,
                  obs_fun = g,
                  p_fun = (p_log*p_pert),
                  perturbation_prediction = perturbation_prediction)
# myfits %>% as.parframe() %>% plotValues()

(best_fit <- myfits %>% as.parframe() %>% as.parvec())
r_alpha_fun(best_fit, pars = pars, p_fun = (p_log*p_pert), obs_fun = g, perturbation_prediction = perturbation_prediction) %>% round(3)

```

# Compute the local response matrix in dependence of a
Use par_opt_setting to define, to which module(s) the complex should be added.
```{r, warning=FALSE}
# par_opt_settings <- list("loga_xy", "loga_tox_xy", "loga_toy_xy", c("loga_tox_xy", "loga_toy_xy")) %>% set_names(1:4)
# par_opt_settings <- par_opt_settings[1:2]
# dr_list <- lapply(par_opt_settings, function(i) {
#   r_opt_dose_response(which_par = "logk1", 
#                       dosages = pars["logk1"],#+seq(-2,2,by = 2),
#                       alpha_oars = alpha_oars[i],
#                       alpha_scan_range = sort(unique(seq(-10,10,by = .1))),
#                       pars = pars
#   )
# })

# saveRDS(dr_list, file = "Prabakaran_dr_list.rds")

```


# Plot the local response matrix in dependence of a
 - Different opacities correspond to different communicating species

```{r plot}
dr_list <- readRDS("Prabakaran_dr_list.rds")

plot_data <- dr_list %>%   
  # extract2(1) %>%
  combine_dr_list() %>% 
  filter(par_opt_setting %in% 1:2) %>%
  filter(near(dose,log(0.1))) %>%
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  # filter(alpha >-5, alpha <3) %>% 
  filter(matrix == "r_alpha") %>%
  {
    .$matrix[.$matrix == "r_alpha"] <- "r"
    .$matrix[.$matrix == "r_opt"] <- "r(a = a_opt)"
    .$matrix <- .$matrix %>% factor(levels = c("r", "r(a = a_opt)", "r_kept"))
    .
  } %>% 
  mutate(Element = r_element) %>% 
  # mutate(points = value) %>% 
  # { logpoints <- c(-8.5,-0.7,2.1,9)
  #   nears <- seq(-10,10,by=0.1)[apply(sapply(logpoints, function(i) near(seq(-10,10,by=0.1),i)),1,any)]
  #   .[!(.$alpha %in% nears),"points"] <- NA
  #   .[(.$alpha < (-6))|(.$alpha > (7)),"value"] <- NA
  #   filter(., alpha >= (-9))
  # } %>% 
  {
    .$par_opt_setting[.$par_opt_setting == 1] <- "X* and Y*"
    .$par_opt_setting[.$par_opt_setting == 2] <- "X*"
    .$par_opt_setting <- .$par_opt_setting %>% factor(levels = c("X* and Y*","X*"))
    .
  } %>%
  
  
  # linear x axis
  mutate(alpha = exp(alpha)) %>%
  filter(alpha<5) %>%
  filter(!is.na(value)) %>%
  {.} %T>% {assign("nears", c(min(.$alpha), 0.4965853, 4.953032), envir = .GlobalEnv)} %>% #assign values where points should be to .GlobalEnv
  mutate(points = replace(value, map_lgl(alpha, . %>% near(nears, tol = 1e-6) %>% any %>% `!`), NA)) %>% #filter(!is.na(points)) %>% print
  # choose par_opt_settings to plot, uncomment alpha in ggplot call, if there is only one par_opt_setting
  filter(par_opt_setting == "X*")  

# Print the matrices at the points
map(nears, function(i) {
  plot_data  %>% 
  filter( near(alpha, i, 1e-6), par_opt == "loga_tox_xy") %>% 
  .$value %>% c(-1, ., -1) %>% matrix(ncol = 2) %>% round(2) %>% 
  xtable() %>% print(tabular.enivronment = "pmatrix", floating = FALSE, hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE) %>% 
  str_replace_all(c("tabular"= "pmatrix", "\\{rr\\}" = "", "\\\\begin" = "$\\\\begin")) %>% paste0(., "$") %>% 
  cat 
})

myplot <- plot_data %>%   
  ggplot(mapping = aes(x = alpha, y = value, color = Element
                       # uncomment for one par_opt_setting only
                       # , alpha = par_opt_setting
                       )) +
  geom_line() +
  theme_dMod() +
  # scale_color_dMod() +
  scale_colour_manual(values = c("blue", "red", "green")) +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  # geom_rect(xmin = -0.7, xmax = 3.2, ymin = -10, ymax = 10, alpha = 0.01, size = 0)+
  geom_point(aes(y = points), size = 3)+
  # facet_grid(.~par_opt_setting, scales = "free")+
  # facet_grid(matrix~par_opt_setting, scales = "free")+
  scale_alpha_discrete(name = "Complex \nadded to", range = c(0.3,1)) +
  # scale_x_continuous(breaks = c(-5,0,5))+
  xlab("\tFree parameter a") +
  ylab("Connection coefficient")
# plotly::ggplotly(myplot)
myplot




ggshave(plot = myplot,
       filename = paste0("~/Promotion/Writing/Papers/2017 02 MRA optimization procedure Paper/pictures/Algorithm_linear_axis.png"),
       width = 10,
       height = 8,
       units = "cm",
       device = "png",
       check_overwrite = F
       , commit_script = "Changed color of r21 to blue"
       )



```



```{r plot adding complexes to both modules}
dr_list <- readRDS("Prabakaran_dr_list.rds")

plot_data <- dr_list %>%   
  # extract2(1) %>%
  combine_dr_list() %>% 
  filter(par_opt_setting %in% 1:2) %>%
  filter(near(dose,log(0.1))) %>%
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  # filter(alpha >-5, alpha <3) %>% 
  filter(matrix == "r_alpha") %>%
  {
    .$matrix[.$matrix == "r_alpha"] <- "r"
    .$matrix[.$matrix == "r_opt"] <- "r(a = a_opt)"
    .$matrix <- .$matrix %>% factor(levels = c("r", "r(a = a_opt)", "r_kept"))
    .
  } %>% 
  mutate(Element = r_element) %>% 
  # mutate(points = value) %>% 
  # { logpoints <- c(-8.5,-0.7,2.1,9)
  #   nears <- seq(-10,10,by=0.1)[apply(sapply(logpoints, function(i) near(seq(-10,10,by=0.1),i)),1,any)]
  #   .[!(.$alpha %in% nears),"points"] <- NA
  #   .[(.$alpha < (-6))|(.$alpha > (7)),"value"] <- NA
  #   filter(., alpha >= (-9))
  # } %>% 
  {
    .$par_opt_setting[.$par_opt_setting == 1] <- "X* and Y*"
    .$par_opt_setting[.$par_opt_setting == 2] <- "X*"
    .$par_opt_setting <- .$par_opt_setting %>% factor(levels = c("X* and Y*","X*"))
    .
  } %>%
  
  
  # linear x axis
  mutate(alpha = exp(alpha)) %>%
  filter(alpha<5) %>%
  filter(!is.na(value)) %>%
  {.} %T>% {assign("nears", c(min(.$alpha), 0.4965853, 4.953032), envir = .GlobalEnv)} %>% #assign values where points should be to .GlobalEnv
  mutate(points = replace(value, map_lgl(alpha, . %>% near(nears, tol = 1e-6) %>% any %>% `!`), NA)) %>% #filter(!is.na(points)) %>% print
  # choose par_opt_settings to plot, uncomment alpha in ggplot call, if there is only one par_opt_setting
  filter(par_opt_setting == "X* and Y*") %>% 
  {.}

# Print the matrices at the points
map(nears, function(i) {
  plot_data  %>% 
  filter( near(alpha, i, 1e-6), par_opt == "loga_xy") %>% 
  .$value %>% c(-1, ., -1) %>% matrix(ncol = 2) %>% round(2) %>% 
  xtable() %>% print(tabular.enivronment = "pmatrix", floating = FALSE, hline.after=NULL, include.rownames=FALSE, include.colnames=FALSE) %>% 
  str_replace_all(c("tabular"= "pmatrix", "\\{rr\\}" = "", "\\\\begin" = "$\\\\begin")) %>% paste0(., "$") %>% 
  cat 
})

myplot <- plot_data %>%   
  ggplot(mapping = aes(x = alpha, y = value, color = Element
                       # uncomment for one par_opt_setting only
                       # , alpha = par_opt_setting
                       )) +
  geom_line() +
  theme_dMod() +
  # scale_color_dMod() +
  scale_colour_manual(values = c("blue", "red", "green")) +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  # geom_rect(xmin = -0.7, xmax = 3.2, ymin = -10, ymax = 10, alpha = 0.01, size = 0)+
  geom_point(aes(y = points), size = 3)+
  # facet_grid(.~par_opt_setting, scales = "free")+
  # facet_grid(matrix~par_opt_setting, scales = "free")+
  scale_alpha_discrete(name = "Complex \nadded to", range = c(0.3,1)) +
  scale_y_continuous(breaks = c(-1,0,1,2)) + 
  # scale_x_continuous(breaks = c(-5,0,5))+
  xlab("\tFree parameter a") +
  ylab("Connection coefficient")
# plotly::ggplotly(myplot)
myplot




ggshave(plot = myplot,
       filename = paste0("~/Promotion/Writing/Papers/2017 02 MRA optimization procedure Paper/pictures/Algorithm_linear_axis_add_complex_to_both.png"),
       width = 10,
       height = 8,
       units = "cm",
       device = "png",
       check_overwrite = F
       , commit_script = "Removed par opt setting 1 from adding complexes to both plot"
       )



```
