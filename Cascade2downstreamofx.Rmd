---
title: "Cascade 2 modules downstream of x"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---

# Load libraries and define some useful paths

```{r Libraries, results='hide', echo=FALSE, message=FALSE}
rm(list = ls())
library(plotly)
library(tidyverse)
library(MRAr)
library(scales)
library(xtable)
path <- paste0(getwd(), "/")
pathout <- paste0(path, "Output/")
```

```{r Names for Fit storage of different initial conditions}
fit_name <- "Cascade-2-modules-downstream-of-x"
```


```{r Call render without overwriting any previous documents, echo=FALSE, eval=FALSE, message=FALSE}
mytime <- format(Sys.time(), "%Y%m%d-%H%M")

rmarkdown::render("Cascade2downstreamofx.Rmd", output_file = paste0(pathout, fit_name, mytime, ".pdf"))
beepr::beep("~/Promotion/Software/rimshot.mp3")
```
# Cascade

## Setup Model 
This is the setup of the ODE model.

### Prediction function
odemodel writes a C-function, which is executed in x and xs.
x is a regular prediction function while xs only finds and returns the steady states.
If the odemodel has been calculated already, it can be loaded with "load".
```{r Prediction function Cascade, results='asis'}
modelpath <- paste0(path, "Models/Cascade2downstreamofx/")
modelname   <- "Cascade2downstreamofx"
mymodel     <- as.eqnlist(read.csv(paste0(modelpath, modelname, ".csv")))

# myodemodel <- odemodel(mymodel, modelname = paste0(modelname), deriv = T)
# save(myodemodel, file = paste0(modelpath, "odemodel",modelname, ".RData"))
load(paste0(modelpath, "odemodel",modelname, ".RData"))

# Prediction function
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
print(mymodel)
# mymodel %>% as.eqnvec() %>% print(pander = T)
```

### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.
```{r Observation function with Cx2z2 in x-module}
modules <- modules0 <- c("x2","y2", "z2")

obs <- obs0 <- c("x2 + a_1 * Cx2y1 + a_2 * Cx2z1",
          "y2",
          "z2")
g <-  g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```

### Inner parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}

pars_raw <- read.csv(paste0(modelpath, "pars.csv"), header = FALSE)  # dynamical parameters
pars_raw <- structure(pars_raw$V2, names = as.character(pars_raw$V1))
ic_raw <- read.csv(paste0(modelpath, "IC.csv"), header = F)          # initial conditions
ic_raw <- structure(ic_raw$V2, names = as.character(ic_raw$V1))
# sort ics like they appear in x, so it can be used in stode()
vars_x <- attr(x, "parameters")[attr(x, "parameters") %in% names(ic_raw)]
ic_raw <- ic_raw[vars_x]

pars_inner_opt_0 <- setdiff(attr(g, "parameters"),names(c(pars_raw,ic_raw)))
pars_inner_opt_0 <- structure(rep(0, length(pars_inner_opt_0)), 
                              names = pars_inner_opt_0)

pars_inner_0 <- pars_inner <- c(ic_raw, pars_raw, pars_inner_opt_0)


# check if all parameters are assigned a value. Both lines should evaluate to the same number.
# x_pars <- unique(union((g) %>% attr("parameters"),(xs) %>% attr("parameters")))
# names(pars) %in% x_pars %>% sum()
# x_pars %in% names(pars) %>% sum()
```


### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
The way to implement is this, is
log_pars %>% p_log %>% p_other %>% p_other_2 %>% ...
```{r}
# Logtrafo of all pars
logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
                             names = names(pars_inner_0))


# initial values
logtrafo[c("x2", "Cx2y1", "y2", "Cx2z1", "z2")] <- 0


p_log <- P(trafo = logtrafo,
           compile = TRUE,
           modelname = "p_log")
           

pars_0 <- pars <- structure(log(pars_inner_0+.Machine$double.eps), names = paste0("log", names(pars_inner_0))) 

pars_opt_0 <- pars_opt <- structure(log(pars_inner_opt_0+.Machine$double.eps), names = paste0("log", names(pars_inner_opt_0)))

pars_opt_0 <- pars_opt <- pars_opt_0[c("loga_1", "loga_2")] - pars_opt_0[c("loga_1", "loga_2")] - 9
# pars_0
# p_log(pars_0, deriv = F)
```


## Show the code
### Perturb modules
Now the module can be simulated to generate perturbation data.

### Parameter trafos for convenient perturbation data
Just to show the code...
Set up the perturbations
```{r  which pars are perturbed  Cascade, echo=FALSE}
# Which pars shall be perturbed?
pars_perturbed_0 <- pars_perturbed <- c("logx1" = log(0.8), "logy1" = log(0.8), "logz1" = log(0.8))
```


```{r define perturbation conditions Cascade, echo=FALSE}
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars_0)
# (p_log*p_pert)(pars)
```

### Perturbation data generation and elements to keep
```{r Generate perturbation data, echo=FALSE}
perturbation_prediction_0 <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars_0, deriv = F)
r_kept_0 <- r_kept_fun(obs_fun = g0)

```


```{r}
obj_alpha(pars_opt = pars_opt_0+39)
```



### Fitting
Just to show the code...
```{r Fit Cascade, eval=FALSE}
myfits <- mstrust(obj_alpha, center =  pars_opt_0+36, studyname = "Fits", cores = 3, fits = 3, sd = 1)
myfits %>% as.parframe() %>% plotValues()
best_fit <- myfits %>% as.parframe() %>% as.parvec()
```


## Find good parameter values by fitting parameters to chosen datapoints.
```{r Data generation for steady state fitting}
# Data generation
newsteadystate <- function(steady_states, totals = c(100,100,100)) {
  newss <- c(
    
    x1 = totals[1]-steady_states[1]-steady_states[2]-steady_states[4], # x1
    steady_states[1], # x2
    
    steady_states[2], # cx2y1
    y1 = totals[2]-steady_states[2]-steady_states[3], # y1
    steady_states[3], # y2

    steady_states[4], # cx2z1
    z1 = totals[3]-steady_states[4]-steady_states[5], # z1
    steady_states[5] # z2
    
    )
  if(any(newss < 0)) stop("negative values")
  names(newss) <- mymodel$states
  return(newss)
}



data_fun <- function(steady_states, totals = rep(100,3)) {
  data.frame(name = rep(mymodel$states, 5),
             time = rep(c(0.001, 1000, 2000, 3000, 4000), 
                        each = length(mymodel$states)),
             value = c(c(100, 0, 0, 100, 0, 0, 100, 0),  #initial values
                       rep(newsteadystate(steady_states = steady_states, totals = totals),4) #final values
             ),
             sigma = rep(c(0.01,  1, 0.01, 0.001, 0.0001), 
                         each = length(mymodel$states)),
             condition = "C1",
             stringsAsFactors = F) %>% as.datalist()
}


# # further work on th logtrafo
# logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
#                              names = names(pars_inner_0))
# # Kill Synthesis and degradation
# syn_deg <- c(outer(c("ksyn", "kdeg"), c("x1","y1","z1"), FUN = paste0), 
#               paste0("kdeg", c("x","y", "z"), "2"))
# syn_deg <- structure(rep(0, length(syn_deg)), names = syn_deg)
# logtrafo[names(syn_deg)] <- syn_deg
# 
# # Kill complexes - xz-feedback
# xz_fb <- c("Cy2z1", "a_3", "k111", "k112", "k12")
# xz_fb <- structure(rep(0, length(xz_fb)), names = xz_fb)
# logtrafo[names(xz_fb)] <- xz_fb
# logtrafo[c("x2", "Cx2y1", "y2", "Cy2z1", "z2", "Cx2z2")] <- 0
# 
# 
# 
# # kill zy and zx-feedback and set initial conditions
# logtrafo[c("gainlf", "gainuf")] <- 1
# logtrafo[c("k9", "k10")] <- 200
# 
logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
                      names = names(pars_inner_0))
logtrafo[c("x2", "Cx2y1", "y2", "Cx2z1", "z2")] <- 0
logtrafo[c("a_1", "a_2")] <- 0

p_log_fitting <- P(trafo = logtrafo,
                   condition = "C1",
                   compile = TRUE,
                   modelname = "p_log_fitting")

p_log_fitting_defaults <- parvec(loga_1 = -9,
                                 loga_2 = -9,
                                 logx2 = -36,
                                 logCx2y1 = -36,
                                 logy2 = -36,
                                 logCx2z1 = -36,
                                 logz2 = -36,
                                 logx1 = log(100),
                                 logy1 = log(100),
                                 logz1 = log(100)
                                 )



# steady_states <- c(x2 = 30,
#                   Cx2y1 = 30,
#                   y2 = 30,
#                   Cx2z1 = 30,
#                   z2 = 30)
# totals = rep(100, 3)
find_pars <- function(steady_states, totals = rep(100, 3)) {
  data <- data_fun(steady_states, totals)
  
  pars_without_default <- pars_0[!names(pars_0)%in%names(p_log_fitting_defaults)]
  
  obj <<- normL2(data,(x*p_log_fitting)) + constraintL2(structure(rep(0, length(pars_without_default)), 
                                                                  names = names(pars_without_default)),
                                                        sigma = 0.1)
  set.seed(1)
  myfit <- dMod::mstrust(obj, pars_0, cores = 3, fits = 6, studyname = "FindPars", resultPath = ".Findpars", sd = 1, iterlim = 80)
  # pars <- myfit$argument %>% p_nosyndeg() %>% extract2(1) 
  pars <- myfit %>% as.parframe() %>% as.parvec()
  pars[names(p_log_fitting_defaults)] <- p_log_fitting_defaults
  
  return(pars)
}

names(pars_0)
```

Define the wanted steady states and fit the model to them in order to find pars.
```{r Fit model to generated data to find pars}

pars <- find_pars(steady_states = c(x2 = 30, 
                                    Cx2y1 = 30, 
                                    y2 = 30, 
                                    Cx2z1 = 30, 
                                    z2 = 30))
plot((x * p_log_fitting)(seq(0,1000,length.out = 50), pars, deriv = F))


```


# Create lists for different settings

```{r}
# Debugging chunk

# which_par <- "k1"
# dose <- 0.4
# dosages <- seq(-6,20, by = 3)
pars_opt = pars_opt_0
obs_fun = g
p_fun = (p_log * p_pert)
alpha_scan_range <- seq(-5,5,by=0.5)
# dose <- 0
# pars["logk1"]
```

```{r, eval=FALSE}
# pars["logk9"] <- log(50)
# dose <- 0.4
# which_par <- "loggainuf"
pars[which_par] <- structure(dose, names = which_par)
perturbation_prediction <-  (xs*p_fun)(times = c(0,Inf), pars = pars, deriv = F)
perturbation_prediction
# p_fun(pars)
# R_fun(perturbation_prediction = perturbation_prediction, pars = pars)
R_fun(perturbation_prediction = perturbation_prediction, pars = pars) %>% local_response_matrix_eq10()


ssdr <- compute_ss_dose_responses(which_par, dosages, pars = pars, predfun = (xs*p_log * p_pert))
```

Function to Calculate the dose-response local response matrices
```{r}
compute_ss_dose_responses <- function(which_par, 
                              dosages, 
                              pars = pars_0, 
                              predfun = (xs*p_log)) {

  d_r <- mclapply(dosages, function(dose) {

    mypars <- pars
    mypars[which_par] = dose

    conditions <- attr(predfun, "conditions")
    if(is.null(conditions)) conditions <- "1"

    my_steady_states <-  data.frame(condition = conditions,
                                    dose = dose,
                                    which_par = which_par,
                                    do.call(rbind, predfun(times = c(0,Inf), 
                                                           pars = mypars, 
                                                           deriv = F)))
  }, mc.cores = 4) %>% do.call(rbind, .)

  # exclude time
  d_r <- d_r[,!(colnames(d_r) %in% "time")]

  observed_names <- colnames(d_r)[-c(1:3)]

  d_r <- gather_(data = d_r, key_col = "name", value_col =  "value", gather_cols = observed_names, factor_key = T)
  return(d_r)

}

r_opt_dose_response <- function(which_par,
                                dosages,
                                alpha_scan_range = seq(-9,9,by = 2),
                                pars_opt = pars_opt_0,
                                obs_fun = g,
                                p_fun = (p_log * p_pert),
                                pars = pars_0) {
  
  r_names_0 <- paste0("r", outer(as.character(1:length(modules0)),as.character(1:length(modules0)), paste0))
  
  out <- lapply(dosages, function(dose) {
    
    pars[which_par] <- structure(dose, names = which_par)
    
    perturbation_prediction <-  (xs*p_fun)(times = c(0,Inf), pars = pars, deriv = F)
    
    # r_alpha to plot and to compute r_kept
    r_alpha_df <- sapply(alpha_scan_range, function(a) {
      # print(a) 
      myr <- r_alpha_fun(pars_opt = pars_opt_0 - pars_opt_0 + a, # center around logalpha = 0
                         perturbation_prediction = perturbation_prediction,
                         obs_fun = obs_fun,
                         p_fun = p_fun,
                         pars = pars)
      return(myr)
    }) %>%
      t %>%
      structure(. , dimnames = list(NULL, r_names_0)) %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_alpha", gather_cols = r_names_0)
    
    
    # r_0
    r_0 <- r_alpha_fun(pars_opt = pars_opt_0-pars_opt_0 - 16,
                       perturbation_prediction = perturbation_prediction,
                       obs_fun = obs_fun,
                       p_fun = p_fun,
                       pars = pars)
    
    # r_kept
    r_kept_df <- sapply(alpha_scan_range, function(a) {
      myr <- r_alpha_df %>%
        dplyr::filter(alpha == a) %>%
        extract2("r_alpha") %>%
        matrix(nrow = length(modules0))
      # print(myr)
      return(r_kept_fun2(r_0,myr))
    }) %>%
      add(seq(0,0.05,length.out = 9)) %>%  # könnte man evtl auch mit "jitter" lösen
      t %>%
      structure(. , dimnames = list(NULL, r_names_0)) %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_kept", gather_cols = r_names_0)
    
      r_kept <- r_kept_df  %>%  # könnte man evtl auch mit "jitter" lösen
        extract2(2) %>% 
        is_greater_than(0.5) %>% 
        matrix(ncol = 3) %>%
        t()
    
    # determine the alpha values at which a sign flip occured.
    flipped <- r_kept_df %>%
      tidyr::spread(r_element, r_kept) %>%
      select(-alpha) %>%
      apply(2, diff) %>%
      rbind(0,.) %>%
      apply(1, function(i) as.logical(i) %>% any)
    
    # when no sign flip occurs between two alphas, one can be sure that the alpha_opt, that is found will be found again.
    # No fitting is necessary in this case. Initialize an object (booh) to intermediately store the r_opt to be able to access it within the loop over the alphas
    r_opt_prev <- r_0
    best_fits <- list()
    fits <- list()
    
    # r_opt
    r_opt_df <- sapply(seq_along(alpha_scan_range), function(i) {
      
      if(flipped[i]) { # if a sign flip occured in any of the matrix elements, optimize
        
        r_kept <- r_kept_df %>%
          dplyr::filter(alpha == alpha_scan_range[i] ) %>%
          extract2("r_kept") %>%
          is_greater_than(0.5) %>%
          matrix(nrow = length(modules0))
        
        obj <<- obj_alpha
        
        myfits <- mstrust(obj,
                          center =  pars_opt_0-pars_opt_0 - 2, # center around log(pars_opt_0) = 0
                          studyname = "pars_controlled",
                          resultPath = ".pars_controlled/",
                          cores = 3,
                          fits = 9,
                          sd = 1,
                          perturbation_prediction = perturbation_prediction,
                          r_kept = r_kept,
                          obs_fun = obs_fun,
                          p_fun = p_fun,
                          mypars = pars,
                          iterlim = 50)
        
        mybest_fit <- myfits %>% as.parframe %>% as.parvec
        
        # "prev" = previous wrt alpha, see further up, where r_opt_prev is constructed
        r_opt <- r_alpha_fun(pars_opt = mybest_fit,
                             perturbation_prediction = perturbation_prediction,
                             obs_fun = obs_fun,
                             p_fun = p_fun,
                             pars = pars)
        
        # save r_opt and bestfit outside of this environment
        r_opt_prev <<- r_opt
        fits[[i]] <<- myfits %>% as.parframe
        best_fits[[i]] <<- mybest_fit
        
      } else {
        r_opt <- r_opt_prev
        # print(i)
      }
      return(r_opt)
    }) %>%
      t %>%
      structure(. , dimnames = list(NULL, r_names_0)) %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_opt", gather_cols = r_names_0)
    
    
    steady_states <- (xs*p_fun)(times = c(0,Inf), pars = pars, deriv = F)
    if(any(steady_states[[1]][-1] > 95)) warning("Warning in dose level ", dose, ". Saturation might have been reached. \n", steady_states[[1]][-1], "\n")
    
    
    r_df <- plyr::join(r_alpha_df, r_kept_df) %>% plyr::join(r_opt_df)
    
    r_df <- data.frame(r_df, which_par = which_par, dose = dose)
    
    return(r_df)
  }) %>% 
    do.call(rbind,.)

}
```


```{r}
g
```


```{r}
# steady_states <- c(10,5,10,5,10,0)
# pars <- find_pars(steady_states = steady_states)
# plot((x * p_log_fitting)(seq(0,1000,length.out = 50), pars, deriv = F))
# which_par <- "loggainlf"
dr <- r_opt_dose_response(which_par = "logk1", 
                          pars["logk1"], 
                          pars = pars, 
                          alpha_scan_range = seq(-3,3, by = .1))

# saveRDS(dr, file = paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."), ".rds"))
# saveRDS(pars, file = paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."), "_pars.rds"))
```


```{r}
# steady_states <- c(30,20,30,20,30,0)
# which_par <- "loggainlf"
# dr <- readRDS(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."), ".rds"))
```



# Plot matrix(dose), facet with alpha
```{r}
"bla"
dr %>% 
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter( near(alpha,-9) | near(alpha,0) | near(alpha, 9)) %>%
  # filter(dose < 4) %>%
  gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = r_element)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  # scale_y_continuous(limits = c(-3,3))+
  geom_abline(slope = 0,intercept = 0, linetype = 3)+
  # geom_vline(xintercept = 0.1, linetype = 4) + 
  facet_grid(matrix~alpha, scales = "free")
  # plotly::ggplotly()
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~alpha", ".pdf"), device = "pdf")
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~alpha", ".png"), device = "png")
```

# Plot matrix(alpha), facet with doses
```{r}
seq(-3,6,by = 0.5)

dr %>%   
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  # filter(alpha < 10) %>% 
  # filter(near(dose,-2) |near(dose,0) | near(dose, 0.6) | near(dose, 1)) %>%
  gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>% 
  ggplot(mapping = aes(x = alpha, y = value, color = r_element)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  scale_y_continuous(limits = c(-2,2))+
  geom_abline(slope = 0,intercept = 0, linetype = 3)+
  facet_grid(matrix~dose, scales = "free")
  plotly::ggplotly()
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed .pdf"), device = "pdf")
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed.png"), device = "png")
```

# Extract local response matrices from dose_response data.frame
```{r}
dr %>% 
  gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>% 
  filter(alpha == 0) %>% 
  extract2("value") %>% 
  matrix(nrow = 3) %>% 
  round(digits = 2)

```




# Prediction dose response
```{r}
pars <- readRDS("Output/drplots/loggainlf10.5.10.5.10.0_pars.rds")
which_par <- "loggainlf"
dosages <- seq(-3,3,by = 0.1)
pred_dr <- compute_ss_dose_responses(which_par = which_par, dosages = dosages, pars = pars, predfun = (xs * p_log * p_pert))

mypred_dr <- pred_dr %>% 
  arrange(dose) %>% 
  group_by(dose) 

mypred_dr <- lapply(seq_along(attr(mypred_dr, "in")), function(i) {
  df <- mypred_dr[attr(mypred_dr, "in")[[i]],] %>% 
    spread(condition, value) %>% 
    gather_("condition", "value", c("logx1 + -0.2","logy1 + -0.2","logz1 + -0.2")) %>% 
    group_by(name) %>% 
    mutate(R = 2 * (Ctr-value) / ( Ctr +  value))
}) %>% do.call(rbind,.)

# mypred_dr_plot <- 
mypred_dr %>% 
  ggplot(aes(x = dose, y = R, color = name)) +
  facet_wrap(~condition) + 
  geom_path() + 
  geom_abline(slope = 0,intercept = 0, linetype = 3)+
  geom_vline(xintercept = 0, linetype = 3)+
  theme_dMod()

# ggsave(paste0("Output/drplots/loggainlf10.5.10.5.10.0_R_dose_response.pdf"), dev = "pdf")
# ggsave(paste0("Output/drplots/loggainlf10.5.10.5.10.0_R_dose_response.png"), dev = "png")


```





### Initialize the setting lists
```{r Initialize lists}
pars_perturbed_list <- vector("list", 6)
ic_list_list <- vector("list", 6)
pars_list <- vector("list", 6)
obs_fun_list <- vector("list", 6)
setting_description <- outer(
  paste0("Cx2z2 added to ", c("x-module", "z-module", "both modules"), ", "), 
  c("Small complex concentrations",
    "Large complex concentrations"), 
    paste0)
```

## Many settings
```{r All settings}
obs_fun_list <- rep(list(g0,g1,g2),2)

pars_perturbed_list <- lapply(1:6, function(i) c("logx1" = log(0.5), "logy1" = log(0.5), "logz1" = log(0.5)))

data <- data_fun(50,2,50,2,30,0)
obj <- normL2(data,(x*p_nosyndeg))
myfit <- mstrust(obj, pouter_0, cores = 3, fits = 3, studyname = "FindPars", resultPath = ".Findpars")
pars_list[[1]] <-pars_list[[2]] <-pars_list[[3]] <- pars <- (myfit %>% 
                                                               as.parframe() %>% 
                                                               as.parvec() %>% 
                                                               p_nosyndeg() %>% 
                                                               extract2(1))

data <- data_fun(30,30,30,30,30,0)
obj <- normL2(data,(x*p_nosyndeg))
myfit <- mstrust(obj, pouter_0, cores = 3, fits = 3, studyname = "FindPars", resultPath = ".Findpars")
pars_list[[4]] <-pars_list[[5]] <-pars_list[[6]] <- pars <- (myfit %>% 
                                                               as.parframe() %>% 
                                                               as.parvec() %>% 
                                                               p_nosyndeg() %>% 
                                                               extract2(1))

ic_list_list <- lapply(1:6, function(i) {
  list(k111 = signif(outer(pars_list[[i]]["k111"], exp(c(0,-2,-1,1,2)), "*"),2),
       k12 = signif(outer(pars_list[[i]]["k12"], c(0,exp(c(0,-2,-1,1,2))), "*"),2),
       gainlf = c(1,0,0.3,0.7,0.9))
})

ic_list <- ic_list_list[[1]]
p_ic <- p_ic_fun(reduce_ic_list(ic_list)[[1]])
# plot((x)(times = seq(0,2000, length.out = 50), pars_list[[1]])) + xkcd::theme_xkcd()
# plot((x)(times = seq(0,2000, length.out = 50), pars_list[[4]])) + xkcd::theme_xkcd()
# pars_list[[i]][names(reduce_ic_list(ic_list)[[2]])] <- reduce_ic_list(ic_list)[[2]]
```



# Simulations without noise

Run this only once before knitting and knit the document with the loaded dataset.
```{r Fit multiple conditions Cascade, eval=FALSE}
machine <- "localhost"
fit_job1<- runbg({
  myfits <- mclapply(seq_along(pars_list), function(i) {
    # cat("Setting ", i, " of ", length(pars_list), " \n")
    run_simulations(ic_list = ic_list_list[[i]],
                    nfits = 12,
                    cores = 3,
                    pars = pars_list[[i]],
                    pars_perturbed = pars_perturbed_list[[i]],
                    obs_fun = obs_fun_list[[i]]
                    )
    

  }, mc.cores = 1)
  names(myfits) <- paste0("Setting", seq_along(pars_list))
  myfits
}, machine = machine, filename = "fit_job1")
save.image()
```

```{r Get the fit Cascade, eval=FALSE, message=FALSE, results='hide'}
# mytime <- 0
while(!fit_job1$check()) {
  Sys.sleep(10)
  # mytime <- mytime + 5
}
beepr::beep(2)
multiple_fits <- fit_job1$get()
multiple_fits <- multiple_fits[[machine]]
# multiple_fits
save(list = c("multiple_fits", "pars_list"), file = paste0(pathout,fit_name,".RData"))
# fit_job1$purge()
```



## Rendering
<!-- This is now to be run when pressing "render" -->
```{r Load the fits}
# Load the multiple fits
load(paste0(pathout,fit_name, ".RData"))
```

```{r Analyze Fits to knitr-Document Cascade, results='asis', out.width='45%'}
lapply(seq_along(pars_list), function(setting) {
  
  cat("\\newpage
# Fit setting: ", setting, ": ", setting_description[setting], "
\n
### Standard pars of the following fits \n")
  print(xtable(as.matrix(pars_list[[setting]], nrow = 1), digits = 3), comment = F, floating = F)
    
  
  
  # multiple_fits <- lapply(seq_along(multiple_fits), function(j) {
  #   if(is.null(multiple_fits[[j]]$condition)) multiple_fits[[j]]$condition <- names(multiple_fits)[j]
  #   return(multiple_fits[[j]])
  # })
  output <- lapply(multiple_fits[[setting]], function(sim_result) {
    if(length(sim_result) == 1) return()
    cat("\\newpage
      # condition: ",(sim_result$condition %>% str_split("_") %>% extract2(1) %>% paste(collapse = ", ") %>% str_replace_all("=", " = ")), "\n" )
    cat("\\textbf{Perturbed Parameters}: ", sim_result$pars_perturbed, "\n" )
    
    # Plot the result of the mstrust()
    print(plotValues(sim_result$fits) )
    print(plot(sim_result$prediction))
    
    cat(" \n Local response matrices before and after optimization. \n \n")
    cat(" Left is the local response matrix of free species, right is the matrix with complexes. \n")
    print(ggplot(sim_result$r_alpha_df, mapping = aes(x = alpha, y = value, color = r_element)) +
            geom_line() +
            xkcd::theme_xkcd() +
            scale_color_dMod() +
            scale_x_continuous(breaks = -9:12) +
            # scale_y_continuous(limits = c(-3,3))+
            geom_abline(slope = 0,intercept = 0, linetype = 3))
    cat(" ")
    print(ggplot(sim_result$r_kept_df, mapping = aes(x = alpha, y = value, color = r_element)) +
            geom_line() +
            xkcd::theme_xkcd() +
            scale_color_dMod() +
            scale_x_continuous(breaks = -9:12) +
            # scale_y_continuous(limits = c(-3,3))+
            geom_abline(slope = 0,intercept = 0, linetype = 3))
    cat(" ")
    print(ggplot(sim_result$r_opt_df, mapping = aes(x = alpha, y = value, color = r_element)) +
            geom_line() +
            xkcd::theme_xkcd() +
            scale_color_dMod() +
            scale_x_continuous(breaks = -9:12) +
            scale_y_continuous(limits = c(-3,3))+
            geom_abline(slope = 0,intercept = 0, linetype = 3))    
    
    print(sim_result$best_fits %>% do.call(rbind,.) %>%  matrix(.,nrow = 1, dimnames = list(NULL, names(.))) %>% xtable(digits = 3), comment = F, floating = F)
    
    cat("\n Steady state: \n")
    print(xtable(as.matrix(sim_result$steady_states[[1]])), comment = F, floating = F)
    
    cat("\n All fits: \n")
    print(xtable(sim_result$fits, digits = 4), comment = F, floating = F)
    return()
  })
})
```


## Explore simulations that behaved weirdly
This part is mainly about the simulations in Cascade-x2z2-mass-action20170418-1434. 
There, sometimes r_kept is not in accordance with the two matrices above. See page 40 of the pdf for example.
The problem however is that I don't have the parameters anymore, since some of them seem non-identifiable, so the pars that I get from fitting them to the steady state levels are different everytime I let the document run. 
This poses a problem, because I earlier didn't need to consider this and didn't save the parameters themselves.



# Noisy simulations

Run this only once before knitting and knit the document with the loaded dataset.
```{r Fit multiple conditions noisy, eval=FALSE}
machine <- "tesla"
fit_job1<- runbg({
  myfits <- mclapply(seq_along(pars_list), function(i) {
    # cat("Setting ", i, " of ", length(pars_list), " \n")
    run_simulations_with_noise(ic_list = ic_list_list[[i]],
                    n_samples = 500,
                    sdlog = sdlog_list[[i]],
                    cores = 24,
                    pars = pars_list[[i]],
                    pars_perturbed = pars_perturbed_list[[i]],
                    obs_fun = obs_fun_list[[i]]
                    )
    
  }, mc.cores = 1)
  names(myfits) <- paste0("Setting", seq_along(pars_list))
  myfits
}, machine = machine, filename = "fit_job1")
save.image()
```


```{r Get the fit noisy, eval=FALSE, message=FALSE, results='hide'}
mytime <- 0
while(capture.output(fit_job1$check())[[1]] == "Not ready!") {
  Sys.sleep(5)
  mytime <- mytime + 5
}
beepr::beep(2)
multiple_fits <- fit_job1$get()
multiple_fits <- multiple_fits[[machine]]
# multiple_fits
save(multiple_fits, file = paste0(pathout,fit_name,".RData"))
fit_job1$purge()
```



## Analyze the fits
<!-- This is now to be run when pressing "render" -->
```{r Load the fits noisy, eval=FALSE}
# Load the multiple fits
load(paste0(pathout,fit_name, ".RData"))
```

```{r Analyze Fits to knitr-Document noisy, results='asis', out.width='45%', warning=FALSE, message=FALSE, eval=FALSE}
library(tidyr)
library(dplyr)
wup <- lapply(seq_along(pars_list), function(setting) {
  
  cat("\\newpage")
cat("\n
# Fit setting ", setting, ": ", setting_description[setting])
cat("\n
### Standard pars of the following fits \n")
  print(xtable(as.matrix(pars_list[[setting]], nrow = 1), digits = 3), comment = F, floating = F)
  
  
  # multiple_fits <- lapply(seq_along(multiple_fits), function(j) {
  #   if(is.null(multiple_fits[[j]]$condition)) multiple_fits[[j]]$condition <- names(multiple_fits)[j]
  #   return(multiple_fits[[j]])
  # })
  output <- lapply(multiple_fits[[setting]], function(sim_result) {
    
cat("\\newpage \n
## condition: ",(sim_result$condition %>% str_split("_") %>% extract2(1) %>% paste(collapse = ", ") %>% str_replace_all("=", " = ")), " \n" )
cat("\\textbf{Perturbed Parameters}: ", sim_result$pars_perturbed, "\n" )
cat("\\textbf{Standard deviation of Log-Normal distribution}: ", sim_result$sdlog, "\n" )

    
    # Plot the resulting local response matrices as histograms.
    # The failed simulations have to be removed first. They are recognizable by all elements equalling zero in r_ij
    failed <- sim_result$r_0$r11 == 0
    cat("\
        Number of failed fits: ", sum(failed) , "\n")
    cat("\n
        Distributions before and after optimization: 
        \n")
    if(sum(!failed) == 0) return()
    
    r_0 <- sim_result$r_0[!failed,] %>% tidyr::gather(key = element, value = value, everything())
    r_best_fit <- sim_result$r_best_fit[!failed,] %>% tidyr::gather(key = element, value = value, everything())
    
    # Join the two data.frames together. Since they have the exact same structure, I can just use cbind.
    r <- cbind(r_0, r_best_fit$value)
    names(r) <- c("element", "0", "optimized")
    r <- tidyr::gather_(r, key_col = "alpha", value_col = "value", gather_cols = c("0", "optimized"))
    
    
    print(ggplot(data = r, mapping = aes(x=alpha, y = value, fill = alpha)) + 
            geom_boxplot() + 
            facet_wrap(~element, scales = "free") + 
            theme_dMod() + 
       scale_y_continuous(breaks = scales::pretty_breaks(n = 3)) +
         geom_hline(aes(yintercept = 0))
      )
      
    cat("\n
        Which elements were kept in the optimization procedure? 
        \n")
    
     print(ggplot(data = sim_result$r_kept[!failed,] %>% tidyr::gather(key = element, value = value, everything()),
                 mapping = aes(x=value)) + 
            geom_histogram(stat = "count") + 
            facet_wrap(~element, scales = "free_y") + 
            theme_dMod())
    
    # Plot the prediction
    print(plot(sim_result$prediction))

    
    return()
  })
})

```














<!-- ------------------------------------------------------------------------------------------------- -->












<!-- ------------------------------------------------------------------------------------------------- -->







