---
title: "MST2-Raf"
author: "Daniel Lill"
output: 
  pdf_document:
    keep_tex: true
---

# Load libraries and define some useful paths

```{r Libraries, results='hide', echo=FALSE, message=FALSE}
library(MRAr)
library(scales)
library(xtable)
path <- "~/Promotion/Projects/MRA/Cascade/" #getwd()
pathout <- paste0(path, "Output/")
```

```{r Names for Fit storage of different initial Conditions}
fit_name <- "MST2-Raf"
```

```{r Call render without overwriting any previous documents, echo=FALSE, eval=FALSE}
rmarkdown::render("MST2Raf.Rmd", output_file = paste0(pathout, fit_name, format(Sys.time(), "%Y%m%d-%H%M"), ".pdf"))
```
# Cascade

## Setup Model 
This is the setup of the ODE model.

### Prediction function
odemodel writes a C-function, which is executed in x and xs.
x is a regular prediction function while xs only finds and returns the steady states.
If the odemodel has been calculated already, it can be loaded with "load".
```{r Prediction function Cascade}
modelpath <- paste0(path, "Models/MST2Raf/")
modelname   <- "MST2Raf"
mymodel     <- as.eqnlist(read.csv(paste0(modelpath, modelname, ".csv")))
# mymodel

# myodemodel <- odemodel(mymodel, modelname = paste0(modelname), deriv = T)
# save(myodemodel, file = paste0(modelpath, "odemodel",modelname, ".RData"))
load(paste0(modelpath, "odemodel",modelname, ".RData"))

# Prediction function
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
print(mymodel)
```

### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.

```{r Observation function}
modules <- c("Raf1a", "MST2a_tot","LATS1a", "MEKpp", "ERKpp")

obs <- c(  "Raf1a + a_1*(RaMk+ RapMk)", 
           "k14a/(k14a+k14b)*MST2a+ k14b/(k14a+k14b)*MaF1A + a_2*(pMpR + MpR)", 
           "LATS1a", 
           "ppMEK", 
           "ppERK")
g <- g0 <- Y(as.eqnvec(structure(obs, names = modules)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```

Better modularization (also, set some defaults.)
```{r Observation function the other way round}
modules <- c("Raf1a", "MST2a_tot","LATS1a", "MEKpp", "ERKpp")

obs <- c(  "a_1*Raf1a + (RaMk+ RapMk)", 
           "a_2*(k14a/(k14a+k14b)*MST2a+ k14b/(k14a+k14b)*MaF1A) + (pMpR + MpR)", 
           "LATS1a", 
           "ppMEK", 
           "ppERK")
g1 <- Y(as.eqnvec(structure(obs, names = modules)), mymodel, compile = TRUE, modelname = "obsfn1", attach.input = FALSE)
```


### Parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}

pars_raw <- read.csv(paste0(modelpath, "pars.csv"), header = FALSE)  # dynamical parameters
pars_raw <- structure(pars_raw$V2, names = as.character(pars_raw$V1))
ic_raw <- read.csv(paste0(modelpath, "IC.csv"), header = F)          # initial conditions
ic_raw <- structure(ic_raw$V2, names = as.character(ic_raw$V1))
# sort ics like they appear in x, so it can be used in stode()
vars_x <- attr(x, "parameters")[attr(x, "parameters") %in% names(ic_raw)]
ic_raw <- ic_raw[vars_x]

pars_opt_0 <- setdiff((g) %>% attr("parameters"),names(c(pars_raw,ic_raw)))
pars_opt_0 <- structure(rep(0, length(pars_opt_0)), names = pars_opt_0)

pars_0 <- pars <- c(ic_raw, pars_raw, pars_opt_0)


# check if all parameters are assigned a value. Both lines should evaluate to the same number.
# x_pars <- unique(union((g) %>% attr("parameters"),(xs) %>% attr("parameters")))
# names(pars) %in% x_pars %>% sum()
# x_pars %in% names(pars) %>% sum()
```


## Show the code
### Perturb modules
Now the module can be simulated to generate perturbation data.

### Parameter trafos for convenient perturbation data
Just to show the code...
Set up the perturbations
```{r  which pars are perturbed  Cascade, results='hide'}
# Which pars shall be perturbed?
which_pars_perturbed_0 <- which_pars_perturbed <- c("pRaf1", "MST2","LATS1", "MEK", "ERK")
```


```{r define perturbation conditions Cascade, results='hide'}
p_pert <- p_pert_fun(which_pars_perturbed = which_pars_perturbed_0,
                     perturbation_strength = 1.1,
                     pars = pars_0)
```

### Perturbation data generation and elements to keep
Just to show the code...
This function will actually be evaluated each time a new condition is tested.
```{r Generate perturbation data Cascade, eval=FALSE}
perturbation_prediction_0 <-  (xs*p_pert)(times = c(0,Inf), pars = pars_0, deriv = F)
# debugonce(r_kept_fun)
r_kept_0 <- r_kept_fun(obs_fun = g0, obs_fun_2 = g1)
```

### Fitting
Just to show the code...
```{r Fit Cascade, eval=FALSE}
myfits <- mstrust(obj_alpha, center =  pars_opt_0+0.5, studyname = "Fits", cores = 3, fits = 3, sd = 0.3)
myfits %>% as.parframe() %>% plotValues()
best_fit <- myfits %>% as.parframe()
best_fit <- best_fit[abs(best_fit$a_1) < 1 & abs(best_fit$a_2) < 1, ] %>% as.parvec()
```



## Find good Parameter values to compare behaviour for different conditions
Run this chunk of code with the "plot"-line uncommented to see predictions.
Once happy, comment out the plotting and proceed.
```{r Find good pars Cascade, eval=FALSE}
ic_list <- list(k7 = 0.1,
                k4 = 0.1,
                gainuf = c(0,0.1,0.5,1,5,10,20,50,100)
                )
pars <- pars_0
pars[names(reduce_ic_list(ic_list)[[2]])] <- reduce_ic_list(ic_list)[[2]]
ic_list <- reduce_ic_list(ic_list)[[1]]
p_ic <- p_ic_fun(ic_list)
plot((x*p_ic)(times = seq(0,1000, length.out = 50), pars))
# print(pars)
mymodel
```

## Fit and analyze different conditions and perturbations

### Create lists for different settings
```{r Summary of pars and ic_list Cascade}
which_pars_perturbed_list <- list()
ic_list_list <- list()
pars_list <- list()
obs_fun_list <- list()
setting_description <- " "
```

## Setting 1: Feedback from z2 to y2_z1_to_comp
```{r Setting1  Cascade}
obs_fun_list <- lapply(1, function(i) g0)
obs_fun_2_list <- lapply(1, function(i) g1)
which_pars_perturbed_list <- list(c("x1", "y1","z1"))
                                       
ic_list_list <- lapply(1, function(i) list(k4=c(1), gainlf = c(0,0.1,1,10,100)))

pars <- pars_0

# pars[names(reduce_ic_list(ic_list)[[2]])] <- reduce_ic_list(ic_list)[[2]] #This needs to be considered, when I want to test more parameter-conditions
# ic_list <- reduce_ic_list(ic_list)#[[1]]
# p_ic <- p_ic_fun(ic_list)
# plot((x*p_ic)(times = seq(0,1000, length.out = 50), pars))
# 
pars_list <- lapply(1, function(i) pars)
# # ic_list_list[[1]] <- ic_list
```

### Plot of the different feedback strengths
This value is multiplied with the reaction rate k61\*y2\*z1
```{r}

# mymodel
# pars["k10"]
gain <- function(z2, gainlf, k10) (1 + gainlf*(z2/(k10 + z2)))/(1 + (z2/(k10 + z2)))
mydf <- data.frame(x=rep(1:40,5))
df <- within(mydf, {
  y <- lapply(c(0,0.1,2,10,50), function(i) gain(unique(x), i, pars["k10"])) %>% do.call(c,.)
  color <- rep(as.character(c(0,0.1,2,10,50)), each = length(unique(x)))})
qplot(data= df, x=x,y=y, color = color, geom = "path", xlab = "z2", ylab = "Multiplicative factor") + theme_dMod() + scale_color_dMod() + guides(color=guide_legend(title = "gainlf"))
```




## Fit the multiple conditions and save the fits to a file.
Run this only once before knitting and knit the document with the loaded dataset.
```{r Fit multiple conditions Cascade, eval=FALSE}
machine <- "localhost"
fit_job1<- runbg({
  myfits <- mclapply(seq_along(pars_list), function(i) {
    # cat("Setting ", i, " of ", length(pars_list), " \n")
    run_simulations(ic_list = ic_list_list[[i]],
                    nfits = 6,
                    cores = 3,
                    pars = pars_list[[i]],
                    which_pars_perturbed = which_pars_perturbed_list[[i]],
                    obs_fun = obs_fun_list[[i]],
                    obs_fun_2 = obs_fun_2_list[[i]]
                    )
    

  }, mc.cores = 1)
  names(myfits) <- paste0("Setting", seq_along(pars_list))
  myfits
}, machine = machine, filename = "fit_job1")
save.image()
```

```{r Get the fit Cascade, eval=FALSE, message=FALSE, results='hide'}
mytime <- 0
while(!fit_job1$check()) {
  Sys.sleep(5)
  mytime <- mytime + 5
}
beepr::beep(2)
multiple_fits <- fit_job1$get()
multiple_fits <- multiple_fits[[machine]]
# multiple_fits
save(multiple_fits, file = paste0(pathout,fit_name,".RData"))
fit_job1$purge()
```



## Analyze the fits
<!-- This is now to be run when pressing "render" -->
```{r Analyze Fits to knitr-Document Cascade, results='asis', out.width='45%'}
# Load the multiple fits
load(paste0(pathout,fit_name, ".RData"))

lapply(seq_along(pars_list), function(setting) {
  
  cat("\\newpage
# Fit setting: ", setting, ": ", setting_description[setting], "
\n
### Standard pars of the following fits \n")
  print(xtable(as.matrix(pars_list[[setting]], nrow = 1), digits = 3), comment = F, floating = F)
    
  
  
  # multiple_fits <- lapply(seq_along(multiple_fits), function(j) {
  #   if(is.null(multiple_fits[[j]]$condition)) multiple_fits[[j]]$condition <- names(multiple_fits)[j]
  #   return(multiple_fits[[j]])
  # })
  output <- lapply(multiple_fits[[setting]], function(cond) {
    
    cat("\\newpage
      # Condition: ",(cond$condition %>% str_split("_") %>% extract2(1) %>% paste(collapse = ", ") %>% str_replace_all("=", " = ")), "\n" )
    cat("\\textbf{Perturbed Parameters}: ", cond$which_pars_perturbed, "\n" )
    
    # Plot the result of the mstrust()
    print(plotValues(cond$all_fits) )
    print(plot(cond$prediction))
    
    cat(" \n Local response matrices before and after optimization. \n \n")
    cat(" Left is the local response matrix of free species, right is the matrix with complexes. \n")
    print(xtable(cbind(cond$r_0, rep(0, nrow(cond$r_0)), cond$r_1), digits = 5), comment = F, floating = F)
    cat(" ")
    print(xtable(cond$r_kept, digits = 5), comment = F, floating = F)
    cat(" ")
    print(xtable(cond$r_best_fit, digits = 5), comment = F, floating = F)
    
    cat("\n Best fit with reasonable parameter: \n")
    print(cond$best_fit %>% unclass %>%  matrix(.,nrow = 1, dimnames = list(NULL, names(.))) %>% xtable(digits = 3), comment = F, floating = F)
    
    cat("\n Steady state: \n")
    print(xtable(as.matrix(cond$steady_states[[1]])), comment = F, floating = F)
    
    cat("\n All fits: \n")
    print(xtable(cond$all_fits, digits = 4), comment = F, floating = F)
    return()
  })
})
```












<!-- ------------------------------------------------------------------------------------------------- -->












<!-- ------------------------------------------------------------------------------------------------- -->







