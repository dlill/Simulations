---
title: "Cascade - x2z2 mass action feedback"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---

# Load libraries and define some useful paths

```{r Libraries, results='hide', echo=FALSE, message=FALSE}
rm(list = ls())
library(MRAr)
library(scales)
library(xtable)
path <- paste0(getwd(), "/")
pathout <- paste0(path, "Output/")
```

```{r Names for Fit storage of different initial conditions}
fit_name <- "Cascade most general obsfun"
```


```{r Call render without overwriting any previous documents, echo=FALSE, eval=FALSE, message=FALSE}
mytime <- format(Sys.time(), "%Y%m%d-%H%M")

rmarkdown::render("Cascade.Rmd", output_file = paste0(pathout, fit_name, mytime, ".pdf"))
beepr::beep("~/Promotion/Software/rimshot.mp3")
```
# Cascade

## Setup Model 
This is the setup of the ODE model.

### Prediction function
odemodel writes a C-function, which is executed in x and xs.
x is a regular prediction function while xs only finds and returns the steady states.
If the odemodel has been calculated already, it can be loaded with "load".
```{r Prediction function Cascade, results='asis'}
modelpath <- paste0(path, "Models/Cascade/")
modelname   <- "Cascade"
mymodel     <- as.eqnlist(read.csv(paste0(modelpath, modelname, ".csv")))

# myodemodel <- odemodel(mymodel, modelname = paste0(modelname), deriv = T)
# save(myodemodel, file = paste0(modelpath, "odemodel",modelname, ".RData"))
load(paste0(modelpath, "odemodel",modelname, ".RData"))

# Prediction function
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
print(mymodel)
# mymodel %>% as.eqnvec() %>% print(pander = T)
# myodemodel[[1]] %>% attr("eq")
```






### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.


```{r Observation function with Cx2z2 in x-module}
# modules <- modules0 <- c("x2","y2", "z2")
# 
# obs <- obs0 <- c("x2+a_1*Cx2y1",
#           "y2+a_2*Cy2z1",
#           "z2+a_3*Cx2z2")
# g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```


```{r Most general observation function}
modules <- modules0 <- c("X","Y", "Z")

mypars_opt <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
mypars_opt[c(3,4,7,8,9)] <- "0"

mycomplexes <- matrix(c("Cx2y1", "Cy2z1", "Cx2z2"), ncol = 1)

samepars_opt <- paste0("a_", outer(rep("C",3), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
samepars_opt[c(3,4,7,8,9)] <- "0"

obs <- obs0 <- paste(c("x2", "y2", "z2"), "+", prodSymb(mypars_opt, mycomplexes), "+", prodSymb(samepars_opt, mycomplexes))


g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```


### Inner parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}

pars_raw <- read.csv(paste0(modelpath, "pars.csv"), header = FALSE)  # dynamical parameters
pars_raw <- structure(pars_raw$V2, names = as.character(pars_raw$V1))
ic_raw <- read.csv(paste0(modelpath, "IC.csv"), header = F)          # initial conditions
ic_raw <- structure(ic_raw$V2, names = as.character(ic_raw$V1))
# sort ics like they appear in x, so it can be used in stode()
vars_x <- attr(x, "parameters")[attr(x, "parameters") %in% names(ic_raw)]
ic_raw <- ic_raw[vars_x]

pars_inner_opt_0 <- setdiff(attr(g, "parameters"),names(c(pars_raw,ic_raw)))
pars_inner_opt_0 <- structure(rep(0, length(pars_inner_opt_0)), 
                              names = pars_inner_opt_0)

pars_inner_0 <- pars_inner <- c(ic_raw, pars_raw, pars_inner_opt_0)


# check if all parameters are assigned a value. Both lines should evaluate to the same number.
# x_pars <- unique(union((g) %>% attr("parameters"),(xs) %>% attr("parameters")))
# names(pars) %in% x_pars %>% sum()
# x_pars %in% names(pars) %>% sum()
```


### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
The way to implement is this, is
log_pars %>% p_log %>% p_other %>% p_other_2 %>% ...
```{r}
# Logtrafo of all pars
logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
                             names = names(pars_inner_0))
# Kill Synthesis and degradation
syn_deg <- c(outer(c("ksyn", "kdeg"), c("x1","y1","z1"), FUN = paste0), 
              paste0("kdeg", c("x","y", "z"), "2"))
syn_deg <- structure(rep(0, length(syn_deg)), names = syn_deg)
logtrafo[names(syn_deg)] <- syn_deg

# Kill xz-feedback
xz_fb <- c("Cy2z1", "k111", "k112", "k12")
xz_fb <- structure(rep(0, length(xz_fb)), names = xz_fb)
logtrafo[names(xz_fb)] <- xz_fb

# initial values
logtrafo[c("x2", "Cx2y1", "y2", "Cy2z1", "z2", "Cx2z2")] <- 0



p_log <- P(trafo = logtrafo,
           # compile = TRUE,
           modelname = "p_log")
           

pars_0 <- pars <- structure(log(pars_inner_0+.Machine$double.eps), names = paste0("log", names(pars_inner_0))) 

pars_opt_0 <- pars_opt <- structure(log(pars_inner_opt_0+.Machine$double.eps), names = paste0("log", names(pars_inner_opt_0)))

# pars_0
# p_log(pars_0, deriv = F)
```


## Show the code
### Perturb modules
Now the module can be simulated to generate perturbation data.

### Parameter trafos for convenient perturbation data
Just to show the code...
Set up the perturbations
```{r}
# Which pars shall be perturbed?
pars_perturbed_0 <- pars_perturbed <- c("logx1" = log(0.9), "logy1" = log(0.9), "logz1" = log(0.9))
# pars_perturbed_0 <- pars_perturbed <- c("logx1" = log(0.8), "logy1" = log(0.8), "logz1" = log(0.8))



pars_perturbed
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)

```


```{r  which pars are perturbed  Cascade}

# pars <- c(100,0,0,100,0,0,100,0,0,
#           14.766,0.241,1058.451,5.295,
#           0.003,
#           0.012,0.022,
#           1150.484,
#           50,
#           0.00065,
#           0.005,0.023,
#           550.208,13.304,50,50,
#           1,1,
#           0,0,0,0,0,0,00,0,0,0,0,0,
#           rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0)) # large complexes, made dr_lists with that
# # print("")
# pars <- c(100,0,0,100,0,0,100,0,0,
#           100,1.5,100,1,     0.002,0.4,0.05,
#           100,5,            0.005,0.4,0.05,
#           100,1,
#           100,100,1,1,
#           0,0,0,0,0,0,00,0,0,0,0,0,
#           rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0))

# large complex concentrations which have nicer pars. Tested different perturbations with those parameters
pars <- c(100,0,0,100,0,0,100,0,0,
          100,1.5,100,1,     0.01,0.4,0.05,
          100,5,            0.05,0.4,0.008,
          100,1,
          100,100,1,1,
          0,0,0,0,0,0,00,0,0,0,0,0,
          rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0))
pars

pars_0 <- pars <- log(pars+.Machine$double.eps) %>% set_names(names(pars_0))# large complex concentrations
# p_log(pars)

# (p_log*p_pert)(pars)

perturbation_prediction_0 <- perturbation_prediction <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars, deriv = F)

# mytime <- 2000
# (x*p_log*p_pert)(times = seq(0,2000, length.out = 50), pars = pars) %>%
#   # getDerivs() %>%
#   # extract2(1) %>%
#   # apply_expression({x[,c(str_detect(colnames(x), "(Cx2y1\\.)|time"))]}) %>% prdlist() %>% set_names("blas") %>%
#   plotPrediction()

# perturbation_prediction %>% lapply(round,1)

subs <- c("loga_Cxy", "loga_Cyz")


r_kept_0 <- r_kept_fun(pars_opt = pars_opt[subs],
                       perturbation_prediction = perturbation_prediction, 
                       obs_fun = g,
                       p_fun = (p_log * p_pert), 
                       pars = pars,
                       alpha = -log(0+.Machine$double.eps))
r_kept_0[7]<- F
r_kept_0

# r_kept_0 <- c(F,F,T,T,F,F,F,T,F) %>% matrix(ncol = 3)

r_0 <-   R_fun(pars_opt = pars_opt[subs],
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p_log*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r_0%>% round(2)

r_1 <-   R_fun(pars_opt = structure(rep(0, length(subs)), names = subs),
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p_log*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r_1 %>% round(2)


# matrix(c(F,F,F,T,F,F,F,T,F), ncol = 3)
myfits <- mstrust(obj_alpha, center =  structure(rep(0, length(subs)), names = subs), studyname = "Fits", cores = 3, fits = 3, sd = 1, mypars = pars, perturbation_prediction = perturbation_prediction_0, r_kept = r_kept_0)
# myfits %>% as.parframe() 
best_fit <- myfits %>% as.parframe() %>% as.parvec()
exp(best_fit)
r_alpha_fun(pars_opt = unclass(best_fit), pars = pars, perturbation_prediction = perturbation_prediction) %>% round(2)
```



# Dose response plots
```{r, eval=FALSE}
par_opt_names <- pars_opt_0 %>% names %>% sort

par_opt_settings <- list(par_opt_names[c(1,2)]
                         , par_opt_names[c(3,5)]
                         # ,par_opt_names[c(4,6)]
                         # ,par_opt_names[c(3,5,4,6)]
                         )
dr_list <- lapply(seq_along(par_opt_settings), function(i) {
  # list(
  r_opt_dose_response(which_par = "loggainuf",
                      dosages = sort(unique(c(-9:5, seq(-3,3,by = 0.5)))),
                      pars = pars,
                      alpha_scan_range = seq(-3,3,by = 0.05),
                      pars_opt = pars_opt_0[par_opt_settings[[i]]])
  # )
})

dr_list2 <- lapply(seq_along(par_opt_settings), function(i) {
  r_opt_dose_response(which_par = "loggainlf",
                      dosages = sort(unique(c(-9:5, seq(-3,3,by = 0.5)))),
                      pars = pars,
                      alpha_scan_range = seq(-3,3,by = 0.05),
                      pars_opt = pars_opt_0[par_opt_settings[[i]]])
})
save(dr_list, dr_list2, file = "Output/dr_lists Cascade nice pars.RData")
load("Output/dr_lists Cascade nice pars.RData")

mydr <- c(dr_list,dr_list2) %>% combine_dr_list()
```


# General plotting functions
Plot as dos-response with alpha as facets
```{r Plot generation}
# load("Output/2017-07-24 dr_lists large complex concentrations.RData")
# load("Output/dr_lists Cascade nice pars.RData")

myplot <- c(dr_list,dr_list2) %>% 
  combine_dr_list() %>%
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter(dose >= -2, dose <= 2.5) %>%
  filter(par_opt_setting == 1) %>% 
  filter(alpha %in% 0) %>%
  filter(matrix != "r_kept") %>%
  apply_expression({
    x$matrix[x$matrix == "r_alpha"] <- "r(a_i = 1)"
    x$matrix[x$matrix == "r_opt"] <- "r(a = a_opt)"
    x$matrix <- x$matrix %>% factor(levels = c("r(a_i = 1)", "r(a = a_opt)", "r_kept"))
    x
  }) %>% 
  mutate(Element = r_element) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = Element, linetype = Element)) +
  geom_line() +
  theme_dMod() +
  scale_color_dMod() +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  geom_vline(xintercept = 0, linetype = 3, size = 0.1) +
  facet_grid(matrix~., scales = "free")+
  xlab("log(gu)")
plotly::ggplotly(myplot)
ggsave(plot = myplot,
       filename = paste0("~/Promotion/Writing/Papers/2017 02 MRA optimization procedure Paper/pictures/plots/", "gu large sequestration",".png"),
       width = 10,
       height = 10,
       units = "cm",
       device = "png")

```





```{r dr_fun to give r_kept to the calculations, eval=FALSE}
r_opt_dose_response_given_r_kept <- function(which_par,
                                dosages,
                                alpha_scan_range = seq(-9,9,by = 2),
                                pars_opt = pars_opt_0,
                                obs_fun = g,
                                p_fun = (p_log * p_pert),
                                pars = pars_0,
                                r_kept) {


  r_names_0 <- paste0("r", outer(as.character(1:length(modules0)),as.character(1:length(modules0)), paste0))

  out <- lapply(dosages, function(dose) {

    pars[which_par] <- structure(dose, names = which_par)

    perturbation_prediction <-  (xs*p_fun)(times = c(0,Inf), pars = pars, deriv = F)

    # r_alpha to plot and to compute r_kept


    r_alpha_df <- sapply(alpha_scan_range, function(a) {
      # print(a)
      myr <- r_alpha_fun(pars_opt = structure(rep(a, length(pars_opt)), names = names(pars_opt)), # center around logalpha = 0
                         perturbation_prediction = perturbation_prediction,
                         obs_fun = obs_fun,
                         p_fun = p_fun,
                         pars = pars)
      return(myr)
    }) %>%
      t %>%
      structure(. , dimnames = list(NULL, r_names_0)) %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_alpha", gather_cols = r_names_0)


    # r_0
    r_0 <- r_alpha_fun(pars_opt = structure(rep(log(0+.Machine$double.eps), length(pars_opt)), names = names(pars_opt)),
                       perturbation_prediction = perturbation_prediction,
                       obs_fun = obs_fun,
                       p_fun = p_fun,
                       pars = pars)

    # r_kept
    r_kept_df <- sapply(alpha_scan_range, function(a) {
      return(r_kept)
    }) %>%
      add(seq(0,0.05,length.out = length(r_names_0))) %>%  # könnte man evtl auch mit "jitter" lösen
      t %>%
      structure(. , dimnames = list(NULL, r_names_0)) %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_kept", gather_cols = r_names_0)

    # r_kept <- r_kept_df  %>%  # könnte man evtl auch mit "jitter" lösen
    #   extract2(2) %>%
    #   is_greater_than(0.5) %>%
    #   matrix(ncol = (obs_fun %>% attr("ma") %>% extract2(1) %>% attr("eq") %>% length)) %>%
    #   t()

    # determine the alpha values at which a sign flip occured.
    flipped <- r_kept_df %>%
      tidyr::spread(r_element, r_kept) %>%
      select(-alpha) %>%
      apply(2, diff) %>%
      rbind(0,.) %>%
      apply(1, function(i) as.logical(i) %>% any)

    if(any(r_kept_df[r_kept_df[["alpha"]] == min(alpha_scan_range), "r_kept"]>0.5)) {
      flipped[1] <- TRUE
    }
    # when no sign flip occurs between two alphas, one can be sure that the alpha_opt, that is found will be found again.
    # No fitting is necessary in this case. Initialize an object (booh) to intermediately store the r_opt to be able to access it within the loop over the alphas
    r_opt_prev <- r_0
    best_fit_prev <- structure(rep(min(alpha_scan_range), length(pars_opt)), names = names(pars_opt))

    # r_opt
    r_opt_df <- sapply(seq_along(alpha_scan_range), function(i) {

      if(flipped[i]) { # if a sign flip occured in any of the matrix elements, optimize

        r_kept <- r_kept_df %>%
          dplyr::filter(alpha == alpha_scan_range[i] ) %>%
          extract2("r_kept") %>%
          is_greater_than(0.5) %>%
          matrix(nrow = length(modules0))

        assign("obj", obj_alpha, envir = .GlobalEnv)

        myfits <- mstrust(obj,
                          center =  structure(rep(-1, length(pars_opt)), names = names(pars_opt)), # center around log(pars_opt) = -1
                          studyname = "pars_controlled",
                          resultPath = ".pars_controlled/",
                          cores = 3,
                          fits = 9,
                          sd = 1,
                          perturbation_prediction = perturbation_prediction,
                          r_kept = r_kept,
                          obs_fun = obs_fun,
                          p_fun = p_fun,
                          mypars = pars,
                          iterlim = 50)

        mybest_fit <- try(myfits %>% as.parframe %>% as.parvec)

        #

        if(inherits(mybest_fit, "try-error")) {
          r_opt <- r_opt_prev
          mybest_fit <- best_fit_prev
        } else {
          # "prev" = previous wrt alpha, see further up, where r_opt_prev is constructed
          r_opt <- r_alpha_fun(pars_opt = mybest_fit,
                               perturbation_prediction = perturbation_prediction,
                               obs_fun = obs_fun,
                               p_fun = p_fun,
                               pars = pars)

          # save r_opt and bestfit outside of this environment
          r_opt_prev <<- r_opt
          best_fit_prev <<- mybest_fit
        }
      } else {
        r_opt <- r_opt_prev
        mybest_fit <- best_fit_prev
        # print(i)
      }

      r_opt <- c(r_opt, mybest_fit) %>% set_names(c(r_names_0, names(pars_opt)))

      return(r_opt)
    }) %>%
      t %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_opt", gather_cols = r_names_0)


    steady_states <- (xs*p_fun)(times = c(0,Inf), pars = pars, deriv = F)
    if(any(steady_states[[1]][-1] > 95)) warning("Warning in dose level ", dose, ". Saturation might have been reached. \n", steady_states[[1]][-1], "\n")


    r_df <- plyr::join(r_alpha_df, r_kept_df) %>% plyr::join(r_opt_df)
    r_df <- data.frame(r_df, which_par = which_par, dose = dose)

    return(r_df)
  }) %>%
    do.call(rbind,.) %>%
    gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>%
    gather_(key_col = "par_opt", value_col  = "par_opt_value", gather_cols = names(pars_opt))

}

```

```{r compute dr_list with given r_kept, eval=FALSE}
dr_list3 <- lapply(seq_along(par_opt_settings), function(i) {
  # list(
  r_opt_dose_response_given_r_kept(which_par = "loggainuf",
                      dosages = sort(unique(c( seq(-3,3,by = 0.5)))),
                      pars = pars,
                      alpha_scan_range = seq(-3,3,by = 0.05),
                      pars_opt = pars_opt_0[par_opt_settings[[i]]],
                      r_kept = c(F,F,F, T,F,F, F,T,F))
  # )
})

save(dr_list3, file = "Output/dr_list3 Cascade nice pars given r_kept.RData")


```


```{r Plot generation2}
# load("Output/2017-07-24 dr_lists large complex concentrations.RData")
load("Output/dr_lists Cascade nice pars.RData")
load("Output/dr_list3 Cascade nice pars given r_kept.RData")

myplot <- c(dr_list, dr_list2, dr_list3) %>% 
  combine_dr_list() %>%
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter(dose >= -2, dose <= 2.5) %>%
  filter(par_opt_setting == 5) %>% 
  filter(alpha %in% 0) %>% 
  # filter(matrix != "r_kept") %>%
  apply_expression({
    x$matrix[x$matrix == "r_alpha"] <- "r(a_i = 1)"
    x$matrix[x$matrix == "r_opt"] <- "r(a = a_opt)"
    x$matrix <- x$matrix %>% factor(levels = c("r(a_i = 1)", "r(a = a_opt)", "r_kept"))
    x
  }) %>% 
  mutate(Element = r_element) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = Element, linetype = Element)) +
  geom_line() +
  theme_dMod() +
  scale_color_dMod() +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  facet_grid(matrix~., scales = "free")+
  xlab("log(gu)")
plotly::ggplotly(myplot)
# ggsave(plot = myplot,
#        filename = paste0("~/Promotion/Writing/Papers/2017 02 MRA optimization procedure Paper/pictures/plots/", "gu largkjhkjhdstration",".png"),
#        width = 10,
#        height = 10,
#        units = "cm",
#        device = "png")

```





















