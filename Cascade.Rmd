---
title: "Cascade - x2z2 mass action feedback"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---

# Load libraries and define some useful paths

```{r Libraries, results='hide', echo=FALSE, message=FALSE}
rm(list = ls())
library(plotly)
library(tidyverse)
library(MRAr)
library(scales)
library(xtable)
path <- paste0(getwd(), "/")
pathout <- paste0(path, "Output/")
```

```{r Names for Fit storage of different initial conditions}
fit_name <- "Cascade-x2z2-mass-action"
```


```{r Call render without overwriting any previous documents, echo=FALSE, eval=FALSE, message=FALSE}
mytime <- format(Sys.time(), "%Y%m%d-%H%M")

rmarkdown::render("Cascade.Rmd", output_file = paste0(pathout, fit_name, mytime, ".pdf"))
beepr::beep("~/Promotion/Software/rimshot.mp3")
```
# Cascade

## Setup Model 
This is the setup of the ODE model.

### Prediction function
odemodel writes a C-function, which is executed in x and xs.
x is a regular prediction function while xs only finds and returns the steady states.
If the odemodel has been calculated already, it can be loaded with "load".
```{r Prediction function Cascade, results='asis'}
modelpath <- paste0(path, "Models/Cascade/")
modelname   <- "Cascade"
mymodel     <- as.eqnlist(read.csv(paste0(modelpath, modelname, ".csv")))

# myodemodel <- odemodel(mymodel, modelname = paste0(modelname), deriv = T)
# save(myodemodel, file = paste0(modelpath, "odemodel",modelname, ".RData"))
load(paste0(modelpath, "odemodel",modelname, ".RData"))

# Prediction function
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
print(mymodel)
# mymodel %>% as.eqnvec() %>% print(pander = T)
myodemodel[[1]] %>% attr("eq")
```

### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.
```{r Observation function with Cx2z2 in x-module}
modules0 <- c("x2","y2", "z2")

obs0 <- c("x2+a_1*Cx2y1+a_3*Cx2z2",
          "y2+a_2*Cy2z1",
          "z2")
 g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```

```{r Observation function with Cx2z2 in z-module}}
modules1 <- c("x2","y2", "z2")

obs1 <- c("x2+a_1*Cx2y1",
         "y2+a_2*Cy2z1",
         "z2+a_3*Cx2z2")
g <- g1 <- Y(as.eqnvec(structure(obs1, names = modules1)), mymodel, compile = TRUE, modelname = "obsfn1", attach.input = FALSE)
```

```{r Observation function with Cx2z2 in both modules}}
modules2 <- c("x2","y2", "z2")

obs2<- c("x2+a_1*Cx2y1+a_3*Cx2z2",
         "y2+a_2*Cy2z1",
         "z2+a_3*Cx2z2")
g2 <- Y(as.eqnvec(structure(obs2, names = modules2)), mymodel, compile = TRUE, modelname = "obsfn2", attach.input = FALSE)
```


### Inner parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}

pars_raw <- read.csv(paste0(modelpath, "pars.csv"), header = FALSE)  # dynamical parameters
pars_raw <- structure(pars_raw$V2, names = as.character(pars_raw$V1))
ic_raw <- read.csv(paste0(modelpath, "IC.csv"), header = F)          # initial conditions
ic_raw <- structure(ic_raw$V2, names = as.character(ic_raw$V1))
# sort ics like they appear in x, so it can be used in stode()
vars_x <- attr(x, "parameters")[attr(x, "parameters") %in% names(ic_raw)]
ic_raw <- ic_raw[vars_x]

pars_inner_opt_0 <- setdiff(attr(g, "parameters"),names(c(pars_raw,ic_raw)))
pars_inner_opt_0 <- structure(rep(0, length(pars_inner_opt_0)), 
                              names = pars_inner_opt_0)

pars_inner_0 <- pars_inner <- c(ic_raw, pars_raw, pars_inner_opt_0)


# check if all parameters are assigned a value. Both lines should evaluate to the same number.
# x_pars <- unique(union((g) %>% attr("parameters"),(xs) %>% attr("parameters")))
# names(pars) %in% x_pars %>% sum()
# x_pars %in% names(pars) %>% sum()
```


### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
The way to implement is this, is
log_pars %>% p_log %>% p_other %>% p_other_2 %>% ...
```{r}
# Logtrafo of all pars
logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
                             names = names(pars_inner_0))
# Kill Synthesis and degradation
syn_deg <- c(outer(c("ksyn", "kdeg"), c("x1","y1","z1"), FUN = paste0), 
              paste0("kdeg", c("x","y", "z"), "2"))
syn_deg <- structure(rep(0, length(syn_deg)), names = syn_deg)
logtrafo[names(syn_deg)] <- syn_deg

# Kill xz-feedback
xz_fb <- c("Cy2z1", "a_3", "k111", "k112", "k12")
xz_fb <- structure(rep(0, length(xz_fb)), names = xz_fb)
logtrafo[names(xz_fb)] <- xz_fb

# initial values
logtrafo[c("x2", "Cx2y1", "y2", "Cy2z1", "z2", "Cx2z2")] <- 0



p_log <- P(trafo = logtrafo,
           compile = TRUE,
           modelname = "p_log")
           

pars_0 <- pars <- structure(log(pars_inner_0+.Machine$double.eps), names = paste0("log", names(pars_inner_0))) 

pars_opt_0 <- pars_opt <- structure(log(pars_inner_opt_0+.Machine$double.eps), names = paste0("log", names(pars_inner_opt_0)))

pars_opt_0 <- pars_opt <- pars_opt_0[c("loga_1", "loga_2")] - pars_opt_0[c("loga_1", "loga_2")] - 9
# pars_0
# p_log(pars_0, deriv = F)
```


## Show the code
### Perturb modules
Now the module can be simulated to generate perturbation data.

### Parameter trafos for convenient perturbation data
Just to show the code...
Set up the perturbations
```{r  which pars are perturbed  Cascade, echo=FALSE}
# Which pars shall be perturbed?
pars_perturbed_0 <- pars_perturbed <- c("logx1" = log(0.8), "logy1" = log(0.8), "logz1" = log(0.8))
```


```{r define perturbation conditions Cascade, echo=FALSE}
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars_0)
# (p_log*p_pert)(pars)
```

### Perturbation data generation and elements to keep
```{r Generate perturbation data, echo=FALSE}
perturbation_prediction_0 <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars_0, deriv = F)
r_kept_0 <- r_kept_fun(obs_fun = g0)

```


```{r}
obj_alpha(pars_opt = pars_opt_0-pars_opt_0)
```



### Fitting
Just to show the code...
```{r Fit Cascade, eval=FALSE}
myfits <- mstrust(obj_alpha, center =  pars_opt_0-pars_opt_0, studyname = "Fits", cores = 3, fits = 3, sd = 1)
# myfits %>% as.parframe() %>% plotValues()
best_fit <- myfits %>% as.parframe() %>% as.parvec()
```


## Find good parameter values by fitting parameters to chosen datapoints.

Make a parameter trafo to set defaults for the parameter finding process which I later want free again, eg a_1, gainlf etc...
```{r }
logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
                             names = names(pars_inner_0))
# Kill Synthesis and degradation
syn_deg <- c(outer(c("ksyn", "kdeg"), c("x1","y1","z1"), FUN = paste0), 
              paste0("kdeg", c("x","y", "z"), "2"))
syn_deg <- structure(rep(0, length(syn_deg)), names = syn_deg)
logtrafo[names(syn_deg)] <- syn_deg

# Kill complexes - xz-feedback
xz_fb <- c("Cy2z1", "a_3", "k111", "k112", "k12")
xz_fb <- structure(rep(0, length(xz_fb)), names = xz_fb)
logtrafo[names(xz_fb)] <- xz_fb
logtrafo[c("x2", "Cx2y1", "y2", "Cy2z1", "z2", "Cx2z2")] <- 0
# logtrafo[c("x1", "y1", "z1")] <- 100


# kill zy and zx-feedback and set initial conditions
logtrafo[c("a_1", "a_2")] <- 0
logtrafo[c("gainlf", "gainuf")] <- 1
logtrafo[c("k9", "k10")] <- 200

p_log_fitting <- P(trafo = logtrafo,
                   condition = "C1",
                   compile = TRUE,
                   modelname = "p_log_fitting")

p_log_fitting_defaults <- parvec(loggainlf = 0,
                                 loggainuf = 0,
                                 loga_1 = -9,
                                 loga_2 = -9,
                                 logk9 = log(50),
                                 logk10 = log(50),
                                 logx1 = log(100),
                                 logy1 = log(100),
                                 logz1 = log(100))


```

Functions to quickly generate data which saturates to a steady state and a function to run the fits.
```{r}
# Data generation
newsteadystate <- function(steady_states, totals = c(100,100,100)) {
  newss <- c(
    totals[1]-steady_states[1]-steady_states[2]-steady_states[6],
    steady_states[1],
    steady_states[2],
    totals[2]-steady_states[2]-steady_states[3]-steady_states[4],
    steady_states[3],
    steady_states[4],
    totals[3]-steady_states[4]-steady_states[5]-steady_states[6], 
    steady_states[5],
    steady_states[6])
  if(any(newss < 0)) stop("negative values")
  return(newss)
}

data_fun <- function(steady_states, totals = rep(100,3)) {
  ini <- c(100,0,0,100,0,0,100,0,0)
  end <- newsteadystate(steady_states = steady_states, totals = totals)
  
  data.frame(name = rep(mymodel$states, 7),
             time = rep(c(0.1, 200, 500,800,1000,1100,1200), 
                        each = length(mymodel$states)),
             value = c(ini, (ini+end)/2, (ini+5*end)/6, (ini +10*end)/11, end,end,end),
             sigma = rep(c(0.001,0.1,0.01,0.001, 0.001, 0.0001,0.0001), 
                         each = length(mymodel$states)),
             condition = "C1",
             stringsAsFactors = F) %>% as.datalist()
}


find_pars <- function(steady_states, totals = rep(100, 3)) {
  data <- data_fun(steady_states, totals)
  pars_without_default <- pars_0[!names(pars_0)%in%names(p_log_fitting_defaults)]
  obj <<- normL2(data,(x*p_log_fitting)) + constraintL2(structure(rep(0, length(pars_without_default)), 
                                                                  names = names(pars_without_default)),
                                                        sigma = 1)
  # set.seed(1)
  myfit <- mstrust(obj, pars_0-pars_0 - 3, cores = 3, fits = 6, studyname = "FindPars", resultPath = ".Findpars", sd = 3, iterlim = 80)
  # pars <- myfit$argument %>% p_nosyndeg() %>% extract2(1) 
  pars <- myfit %>% as.parframe() %>% as.parvec()
  pars[names(p_log_fitting_defaults)] <- p_log_fitting_defaults
  
  return(pars)
}
```

Parameters
```{r Fit model to generated data to find pars}
# data_fun(steady_states = c(30,2,30,2,30,0))
# steadies <- c(50,2,50,2,50,0)
# pars <- find_pars(steadies)
# plotCombined((x * p_log_fitting)(seq(0,1300,length.out = 50), pars, deriv = F), data = data_fun(steady_states = steadies))


pars <- log(c(100,0,0,100,0,0,100,0,0,
          14.766,0.241,1058,5.3,0.006,0.012,0.022,
          1150,22.24,0.001,0.005,0.023,
          550,13.3,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,0,0,0)) # large complex concentrations
# pars <- log(c(100,0,0,100,0,0,100,0,0,
#           66.4,0.454,616,2.44,0.001,0.02,0.395,
#           510,22.12,0.0002,0.035,0.092,
#           901,9.6,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,0,0,0))
names(pars) <- names(pars_0)
pars


# pars %>%  round() %>% p_log %>% extract2(1) 

# p_log(pars)
# plot((x*p_log_fitting)(seq(0,1000,length.out = 50), pars, deriv = F))


# no_defaults <- logtrafo %>% as.numeric() %>% is.na
# pars %>% 
#   round %>% 
#   unclass() %>% 
#   set_attributes("deriv", NULL) %>% 
#   extract(no_defaults) %>% 
#   print()


```


# Prepare pars for SI

```{r}
SI_pars <- c(100,0,0,100,0,0,100,0,0,
          14,0.24,1000,5,0.006,0.012,0.022,
          1150,22,0.001,0.005,0.023,
          550,13.3,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,0,0,0) # large complex concentrations
SI_pars2 <- c(100,0,0,100,0,0,100,0,0,
          66,0.45,620,2.4,0.001,0.02,0.4,
          500,22,0.0002,0.035,0.092,
          900,10,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,0,0,0) # lower
names(SI_pars2) <- names(SI_pars) <- names(pars_inner)

# plot((x)(seq(0,1000,length.out = 50), SI_pars2, deriv = F))



printSI_pars <- c(SI_pars[-c(2:3,5:6,8:9,28:36,40:42)],
               SI_pars2[-c(2:3,5:6,8:9,28:36,40:42)])
printnames <- names(SI_pars[-c(2:3,5:6,8:9,28:36,40:42)])

printSI_pars %>% 
  matrix(ncol=2) %>% 
  set_rownames(printnames) %>% 
  xtable %>% print() #%>%
  # system("| pandoc -f latex -t docx")
```
# Dose response plots

```{r}
pars <- log(SI_pars) # large complex concentrations
pars[pars==(-Inf)] <- -36

which_par <- "loggainlf"
dr <- r_opt_dose_response(which_par = "loggainlf", 
                          dosages = c(-3,-1,0,1,10), 
                          pars = pars,
                          alpha_scan_range = sort(c(-16,0,16, seq(-3,7,by = 2))))

saveRDS(dr, file = paste0("Output/drplots_all_alphas_at_once/", 
                          "r_kept varying ", 
                          which_par, 
                          # paste(steady_states, collapse = "."), 
                          ".rds"))
saveRDS(pars, file = paste0("Output/drplots_all_alphas_at_once/", 
                            "r_kept varying ", 
                            which_par, 
                            # paste(steady_states, collapse = "."), 
                            "_pars.rds"))
```



Plot as dose-response with alpha as facets
```{r}
"bla"
dr %>% 
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter( near(alpha,0) ) %>%
  # filter(dose < 4) %>%
  gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = r_element)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  # scale_y_continuous(limits = c(-3,3))+
  geom_hline(yintercept = 0, linetype = 3)+
  # geom_vline(xintercept = 0.1, linetype = 4) + 
  facet_grid(matrix~alpha, scales = "free")
  plotly::ggplotly()
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~alpha", ".pdf"), device = "pdf")
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~alpha", ".png"), device = "png")
```

Plot as alpha-response with doses as facets
```{r}
dr %>%   
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  # filter(alpha < 10) %>% 
  filter(near(dose,-2) |near(dose,0) | near(dose, 0.6) | near(dose, 1)) %>%
  gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>% 
  ggplot(mapping = aes(x = alpha, y = value, color = r_element)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  scale_y_continuous(limits = c(-2,2))+
  geom_abline(slope = 0,intercept = 0, linetype = 3)+
  facet_grid(matrix~dose, scales = "free")
  # plotly::ggplotly()
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed .pdf"), device = "pdf")
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed.png"), device = "png")
```

# Plot the matrices a = 0, a = 1, a = inf, a = a_opt
```{r}
modulnames <- c("X*", "Y*", "Z*")

dr %>%   
  filter(alpha == 0) %>%
  filter(dose ==0) %>% 
  select(r_opt) %>% 
  extract2(1) %>% 
  matrix(ncol = 3) %>% 
  round(digits = 2) %>% 
  signif(2) %>% 
  set_colnames(modulnames) %>% 
  set_rownames(modulnames) %>% 
  xtable %>% 
  print()

```

























