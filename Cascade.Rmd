---
title: "Cascade - x2z2 mass action feedback"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---

# Load libraries and define some useful paths

```{r Libraries, results='hide', echo=FALSE, message=FALSE}
rm(list = ls())
library(MRAr)
library(scales)
library(xtable)
path <- paste0(getwd(), "/")
pathout <- paste0(path, "Output/")
```

```{r Names for Fit storage of different initial conditions}
fit_name <- "Cascade most general obsfun"
```


```{r Call render without overwriting any previous documents, echo=FALSE, eval=FALSE, message=FALSE}
mytime <- format(Sys.time(), "%Y%m%d-%H%M")

rmarkdown::render("Cascade.Rmd", output_file = paste0(pathout, fit_name, mytime, ".pdf"))
beepr::beep("~/Promotion/Software/rimshot.mp3")
```
# Cascade

## Setup Model 
This is the setup of the ODE model.

### Prediction function
odemodel writes a C-function, which is executed in x and xs.
x is a regular prediction function while xs only finds and returns the steady states.
If the odemodel has been calculated already, it can be loaded with "load".
```{r Prediction function Cascade, results='asis'}
modelpath <- paste0(path, "Models/Cascade/")
modelname   <- "Cascade"
mymodel     <- as.eqnlist(read.csv(paste0(modelpath, modelname, ".csv")))

# myodemodel <- odemodel(mymodel, modelname = paste0(modelname), deriv = T)
# save(myodemodel, file = paste0(modelpath, "odemodel",modelname, ".RData"))
load(paste0(modelpath, "odemodel",modelname, ".RData"))

# Prediction function
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
print(mymodel)
# mymodel %>% as.eqnvec() %>% print(pander = T)
# myodemodel[[1]] %>% attr("eq")
```






### Modules, their observables and the observation function
Observation function which depends also on the optimization parameters. With their help, the complexes can smoothly be switched on in the observation.


```{r Observation function with Cx2z2 in x-module}
modules <- modules0 <- c("x2","y2", "z2")

obs <- obs0 <- c("x2+a_1*Cx2y1",
          "y2+a_2*Cy2z1",
          "z2+a_3*Cx2z2")
g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```


```{r Most general observation function}
# modules <- modules0 <- c("X","Y", "Z")
# 
# mypars_opt <- paste0("a_", outer(paste0(c("x","y","z"), "_"), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
# mycomplexes <- matrix(c("Cx2y1", "Cy2z1", "Cx2z2"), ncol = 1)
# obs <- obs0 <- paste(c("x2", "y2", "z2"), "+", prodSymb(mypars_opt, mycomplexes)) 
# 
# g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), mymodel, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```


### Inner parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}

pars_raw <- read.csv(paste0(modelpath, "pars.csv"), header = FALSE)  # dynamical parameters
pars_raw <- structure(pars_raw$V2, names = as.character(pars_raw$V1))
ic_raw <- read.csv(paste0(modelpath, "IC.csv"), header = F)          # initial conditions
ic_raw <- structure(ic_raw$V2, names = as.character(ic_raw$V1))
# sort ics like they appear in x, so it can be used in stode()
vars_x <- attr(x, "parameters")[attr(x, "parameters") %in% names(ic_raw)]
ic_raw <- ic_raw[vars_x]

pars_inner_opt_0 <- setdiff(attr(g, "parameters"),names(c(pars_raw,ic_raw)))
pars_inner_opt_0 <- structure(rep(0, length(pars_inner_opt_0)), 
                              names = pars_inner_opt_0)

pars_inner_0 <- pars_inner <- c(ic_raw, pars_raw, pars_inner_opt_0)


# check if all parameters are assigned a value. Both lines should evaluate to the same number.
# x_pars <- unique(union((g) %>% attr("parameters"),(xs) %>% attr("parameters")))
# names(pars) %in% x_pars %>% sum()
# x_pars %in% names(pars) %>% sum()
```


### General log transformation and setting some pars to zero
It's better to do a logtransformation for all Fitting purposes and work with the log-Parameters.
The way to implement is this, is
log_pars %>% p_log %>% p_other %>% p_other_2 %>% ...
```{r}
# Logtrafo of all pars
logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
                             names = names(pars_inner_0))
# Kill Synthesis and degradation
syn_deg <- c(outer(c("ksyn", "kdeg"), c("x1","y1","z1"), FUN = paste0), 
              paste0("kdeg", c("x","y", "z"), "2"))
syn_deg <- structure(rep(0, length(syn_deg)), names = syn_deg)
logtrafo[names(syn_deg)] <- syn_deg

# Kill xz-feedback
xz_fb <- c("Cy2z1", "a_3", "k111", "k112", "k12")
xz_fb <- structure(rep(0, length(xz_fb)), names = xz_fb)
logtrafo[names(xz_fb)] <- xz_fb

# initial values
logtrafo[c("x2", "Cx2y1", "y2", "Cy2z1", "z2", "Cx2z2")] <- 0



p_log <- P(trafo = logtrafo,
           # compile = TRUE,
           modelname = "p_log")
           

pars_0 <- pars <- structure(log(pars_inner_0+.Machine$double.eps), names = paste0("log", names(pars_inner_0))) 

pars_opt_0 <- pars_opt <- structure(log(pars_inner_opt_0+.Machine$double.eps), names = paste0("log", names(pars_inner_opt_0)))

# pars_0
# p_log(pars_0, deriv = F)
```


## Show the code
### Perturb modules
Now the module can be simulated to generate perturbation data.

### Parameter trafos for convenient perturbation data
Just to show the code...
Set up the perturbations
```{r  which pars are perturbed  Cascade, echo=FALSE}
# Which pars shall be perturbed?
pars_perturbed_0 <- pars_perturbed <- c("logx1" = log(0.8), "logy1" = log(0.8), "logz1" = log(0.8))

p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)
# (p_log*p_pert)(pars)

perturbation_prediction_0 <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars, deriv = F)
r_kept_0 <- r_kept_fun(obs_fun = g0)

r_0 <- r_alpha_fun(pars_opt = structure(rep(-36, length(pars_opt_0[c(1,2)])), names=names(pars_opt_0[c(1,2)])),
                   pars=pars)
r_0

(p_log*p_pert)(pars)

pars==pars_0

```



```{r}
obj_alpha(pars = pars_opt_0-pars_opt_0)
```



### Fitting
Just to show the code...
```{r Fit Cascade, eval=FALSE}
myfits <- mstrust(obj_alpha, center =  pars_opt_0-pars_opt_0, studyname = "Fits", cores = 3, fits = 3, sd = 1)
# myfits %>% as.parframe() %>% plotValues()
best_fit <- myfits %>% as.parframe() %>% as.parvec()
```



Parameters
```{r Fit model to generated data to find pars}
# data_fun(steady_states = c(30,2,30,2,30,0))
# steadies <- c(50,2,50,2,50,0)
# pars <- find_pars(steadies)
# plotCombined((x * p_log_fitting)(seq(0,1300,length.out = 50), pars, deriv = F), data = data_fun(steady_states = steadies))


pars <- c(100,0,0,100,0,0,100,0,0,
          14.766,0.241,1058,5.3,0.006,0.012,0.022,
          1150,22.24,0.001,0.005,0.023,
          550,13.3,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,rep(0, length(pars_opt_0))) # large complex concentrations
# pars <- log(c(100,0,0,100,0,0,100,0,0,
#           66.4,0.454,616,2.44,0.001,0.02,0.395,
#           510,22.12,0.0002,0.035,0.092,
#           901,9.6,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,0,0,0))
# names(pars) <- names(pars_0)
# pars


# pars %>%  round() %>% p_log %>% extract2(1) 

# p_log(pars)
# plot((x*p_log_fitting)(seq(0,1000,length.out = 50), pars, deriv = F))


# no_defaults <- logtrafo %>% as.numeric() %>% is.na
# pars %>% 
#   round %>% 
#   unclass() %>% 
#   set_attributes("deriv", NULL) %>% 
#   extract(no_defaults) %>% 
#   print()


```

  

# Prepare pars for SI

```{r}
SI_pars <- c(100,0,0,100,0,0,100,0,0,
          14,0.24,1000,5,0.006,0.012,0.022,
          1150,22,0.001,0.005,0.023,
          550,13.3,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,rep(0, length(pars_opt_0))) # large complex concentrations

SI_pars2 <- c(100,0,0,100,0,0,100,0,0,
          66,0.45,620,2.4,0.001,0.02,0.4,
          500,22,0.0002,0.035,0.092,
          900,10,100,100,1,1,0,0,0,0,0,0,00,0,0,0,0,0,rep(0, length(pars_opt_0))) # lower
names(SI_pars2) <- names(SI_pars) <- names(pars_inner)

# plot((x)(seq(0,1000,length.out = 50), SI_pars2, deriv = F))


printSI_pars <- c(SI_pars[-c(2:3,5:6,8:9,28:36,40:48)],
               SI_pars2[-c(2:3,5:6,8:9,28:36,40:48)])
printnames <- names(SI_pars[-c(2:3,5:6,8:9,28:36,40:48)])

# printSI_pars %>% 
#   matrix(ncol=2) %>% 
#   set_rownames(printnames) %>% 
#   xtable %>% print() 

P
```


# Dose response plots
```{r, eval=FALSE}
pars <- log(pars) %>% set_names(names(pars_0))# large complex concentrations
pars[pars==(-Inf)] <- -36

# mypars_opt %>% set_names(1:9) %>% c()
# obs
# par_opt_settings <- list(c(1,5), # correct modules
#                          c(4,8), # wrong modules
#                          c(1,4,5,8) # added to both modules each
#                          ) %>% set_names(1:length(.))
par_opt_settings <- list(c(1,2))

i <- 1
dr_list <- #lapply(seq_along(par_opt_settings), function(i) {
  list(
  r_opt_dose_response(which_par = "loggainuf",
                      dosages = c(0,1,3),
                      pars = pars,
                      alpha_scan_range = seq(-3,3,by = 0.2),
                      pars_opt = pars_opt_0[par_opt_settings[[i]]])
  )
# })
# 
# dr_list2 <- lapply(par_opt_settings, function(i) {
#   r_opt_dose_response(which_par = "loggainlf", 
#                       dosages = c(-3,-1,0,1,3), 
#                       pars = pars,
#                       alpha_scan_range = seq(-3,3,by = 1),
#                       pars_opt = pars_opt_0[i])
# })
# save(dr_list, dr_list2, file = "Output/dr_lists.RData")
# load("Output/dr_lists.RData")
```

# Plot as alpha-response with doses as facets
```{r}
dr_list %>%   
  extract2(1) %>% 
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  # filter(alpha < 10) %>% 
  filter(near(dose,3)) %>%
  ggplot(mapping = aes(x = alpha, y = value, color = r_element)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  scale_y_continuous(limits = c(-2,2))+
  geom_abline(slope = 0,intercept = 0, linetype = 3)+
  facet_grid(matrix~dose, scales = "free")
plotly::ggplotly()

# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed .pdf"), device = "pdf")
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed.png"), device = "png")
```

# Plot the pars_opt as a function of alpha faceted with respect to alpha-combinations
```{r}
dr_list %>%   
  combine_dr_list %>% 
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter(dose == 0) %>% 
  ggplot(mapping = aes(x = alpha, y = par_opt_value, color = par_opt)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  # scale_y_continuous(limits = c(-2,5))+
  geom_hline(yintercept = 0, linetype = 3) +
  facet_grid(~par_opt_setting, scales = "free")
# plotly::ggplotly()


```

# Profiles
```{r}
best_fit <- dr_list %>%   
  combine_dr_list %>% 
  filter(alpha == 0, par_opt_setting == 3) %>% 
  filter(dose == 0) %>% 
  select(par_opt, par_opt_value) %>% 
  unique() %>% 
  spread(par_opt, par_opt_value) %>% 
  unlist()

perturbation_prediction_0 <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars, deriv = F)
r_kept_0 <- r_kept_fun(pars_opt = pars_opt_0[par_opt_settings[[3]]]-pars_opt_0[par_opt_settings[[3]]]-9)

# myprof <- profile(obj_alpha, best_fit, names(best_fit), limits = c(-2,2))
plotProfile(myprof, maxvalue = 0.2)
plotPaths(myprof, whichPar = "loga_y_xy")

r_alpha_fun(best_fit)
```



Plot as dose-response with alpha as facets
```{r}
"bla"
dr %>% 
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter( near(alpha,0) ) %>%
  # filter(dose < 4) %>%
  # gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = r_element)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  # scale_y_continuous(limits = c(-3,3))+
  geom_hline(yintercept = 0, linetype = 3)+
  # geom_vline(xintercept = 0.1, linetype = 4) + 
  facet_grid(matrix~alpha, scales = "free")
  plotly::ggplotly()
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~alpha", ".pdf"), device = "pdf")
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~alpha", ".png"), device = "png")
```

Plot as alpha-response with doses as facets
```{r}
dr %>%   
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  # filter(alpha < 10) %>% 
  # filter(near(dose,-2) |near(dose,0) | near(dose, 0.6) | near(dose, 1)) %>%
  # gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>% 
  ggplot(mapping = aes(x = alpha, y = value, color = r_element)) +
  geom_line() +
  xkcd::theme_xkcd() +
  scale_color_dMod() +
  # scale_x_continuous(breaks = -9:12) +
  scale_y_continuous(limits = c(-2,2))+
  geom_abline(slope = 0,intercept = 0, linetype = 3)+
  facet_grid(matrix~dose, scales = "free")
  plotly::ggplotly()
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed .pdf"), device = "pdf")
# ggsave(paste0("Output/drplots_all_alphas_at_once/", "r_kept varying ", which_par, paste(steady_states, collapse = "."),"facet~dose", " zoomed.png"), device = "png")
```

# Print the matrices a = 0, a = 1, a = inf, a = a_opt
```{r}
modulnames <- c("X*", "Y*", "Z*")

dr %>%   
  filter(alpha == 0) %>%
  filter(dose ==0) %>% 
  select(r_opt) %>% 
  extract2(1) %>% 
  matrix(ncol = 3) %>% 
  round(digits = 2) %>% 
  signif(2) %>% 
  set_colnames(modulnames) %>% 
  set_rownames(modulnames) %>% 
  xtable %>% 
  print()

```

























