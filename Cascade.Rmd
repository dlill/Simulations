---
title: "Enzymatic Cascade"
author: "Daniel Lill"
output:
  pdf_document:
    keep_tex: yes
---


```{r Initialization, results='hide', echo=FALSE, message=FALSE}
# Load libraries and define some useful paths

rm(list = ls())
library(MRAr)
library(scales)
library(xtable)
```


# Setup Model 
This is the setup of the ODE model.

Our (internal) states x are described by the odemodel which is turned into a prediction via the prediction function x():

dx/dt = f(x,p_dyn)
x = x(t, p_dyn, x_ini)

p_dyn are dynamical parameters like rate constants etc, x_ini are initial values for all states.
The prediction function xs() runs the stimulation until it reaches a steady state.


Then, these states are linked to observables y via the observation function g(). In our case the observables will be the communicating species:

y = g(x, p_obs)

p_obs are observation parameters like scaling factors.


Since all parameters are positive, it is beneficial to use log-parameters, therefore all parameters are transformed to the log-scale. These we call "outer parameters", p_outer. To feed them into our original model, we transform them back to the linear scale ("p_inner") by a parameter transformation function p(). This way, all our calculations can be made in log-space:

p_inner = p(p_outer) = p(log(p_obs), log(p_dyn), log(x_ini))


These three types of functions can be concatenated by the "*"-operator.
g(x(t, p(p_outer))) = g*x*p(t, p_outer)


## Prediction function
odemodel() writes the function f as a C-function, which is called by x and xs.
```{r Prediction function Cascade, results='asis'}
modelpath <- paste0("Models/Cascade/")
modelname   <- "Cascade"
f     <- as.eqnlist(read.csv(paste0(modelpath, modelname, ".csv")))

# If the odemodel has been calculated already, it can be loaded with "load".
# If not, uncomment the next two lines.

# myodemodel <- odemodel(f, modelname = paste0(modelname), deriv = T)
# save(myodemodel, file = paste0(modelpath, "odemodel",modelname, ".RData"))
load(paste0(modelpath, "odemodel",modelname, ".RData"))

# Prediction function for continuous times
x <- Xs(odemodel = myodemodel)
# Prediction function for steady states
xs <- Xs_steady(myodemodel) # When computing steady states, set deriv = F
print(f)
```



## Observation function
Observation function which returns our communicating species. 
The free parameters a_ij are introduced here to perform the linear combination of states which we wish to observe.
We chose to call them pars_opt, since they will be used to optimize the objective function later on.
```{r Most general observation function}
modules <- modules0 <- c("X","Y", "Z")

mypars_opt <- paste0("a_", outer(paste0("to", c("x","y","z"), "_C"), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
mypars_opt[c(3,4,7,8,9)] <- "0"

mycomplexes <- matrix(c("Cx2y1", "Cy2z1", "Cx2z2"), ncol = 1)

samepars_opt <- paste0("a_", outer(rep("C",3), c("xy","yz","zx"), paste0)) %>% matrix(ncol=3)
samepars_opt[c(3,4,7,8,9)] <- "0"

obs <- obs0 <- paste(c("x2", "y2", "z2"), "+", prodSymb(mypars_opt, mycomplexes), "+", prodSymb(samepars_opt, mycomplexes))


g <- g0 <- Y(as.eqnvec(structure(obs0, names = modules0)), f, compile = TRUE, modelname = "obsfn0", attach.input = FALSE)
```


## Inner parameters
Load all parameters and format them for further use.
```{r Parameters Cascade}

pars_raw <- read.csv(paste0(modelpath, "pars.csv"), header = FALSE)  # dynamical parameters
pars_raw <- structure(pars_raw$V2, names = as.character(pars_raw$V1))
ic_raw <- read.csv(paste0(modelpath, "IC.csv"), header = F)          # initial conditions
ic_raw <- structure(ic_raw$V2, names = as.character(ic_raw$V1))
# sort ics like they appear in x, so it can be used in stode()
vars_x <- attr(x, "parameters")[attr(x, "parameters") %in% names(ic_raw)]
ic_raw <- ic_raw[vars_x]

pars_inner_opt_0 <- setdiff(attr(g, "parameters"),names(c(pars_raw,ic_raw)))
pars_inner_opt_0 <- structure(rep(0, length(pars_inner_opt_0)), 
                              names = pars_inner_opt_0)

pars_inner_0 <- pars_inner <- c(ic_raw, pars_raw, pars_inner_opt_0)


# check if all parameters are assigned a value. Both lines should evaluate to the same number.
# x_pars <- unique(union((g) %>% attr("parameters"),(xs) %>% attr("parameters")))
# names(pars) %in% x_pars %>% sum()
# x_pars %in% names(pars) %>% sum()
```


## Parameter transformation function
```{r}
# Logtrafo of all pars
logtrafo <- structure(paste0("exp( log", names(pars_inner_0), ")"), 
                             names = names(pars_inner_0))

# Kill Synthesis and degradation. They can be used to study what happens, if proteins are synthesized and degraded.
syn_deg <- c(outer(c("ksyn", "kdeg"), c("x1","y1","z1"), FUN = paste0), 
              paste0("kdeg", c("x","y", "z"), "2"))
syn_deg <- structure(rep(0, length(syn_deg)), names = syn_deg)
logtrafo[names(syn_deg)] <- syn_deg

# Kill xz-feedback. This is part of a different study.
xz_fb <- c("Cy2z1", "k111", "k112", "k12")
xz_fb <- structure(rep(0, length(xz_fb)), names = xz_fb)
logtrafo[names(xz_fb)] <- xz_fb

# initial values of some complexes.
logtrafo[c("x2", "Cx2y1", "y2", "Cy2z1", "z2", "Cx2z2")] <- 0


p_log <- P(trafo = logtrafo,
           # compile = TRUE,
           modelname = "p_log")
           

# When we transform parameters that have the value 0 to log-pars we run into problems, because p() cannot cope with "-Inf". Therefore, we add a small number to them and trust that they are small enough to lie in the asymptotic range par -> -Inf.
pars_0 <- pars <- structure(log(pars_inner_0+.Machine$double.eps), names = paste0("log", names(pars_inner_0))) 

pars_opt_0 <- pars_opt <- structure(log(pars_inner_opt_0+.Machine$double.eps), names = paste0("log", names(pars_inner_opt_0)))

# pars_0
# p_log(pars_0, deriv = F)
```


# Simulate perturbation data

For the perturbation experiments we use another parameter transformation to scale some parameters.
p_pert_fun automatically generates a parameter transformation function, which returns different sets of parameters for different conditions and a control condition.
Eg. if we have pars_perturbed = c("logx1" = log(0.9)), p_pert_fun(pars_perturbed) will return a parameter transformation with the control condition with unchanged parameters and one condition in which logx' = logx + log(0.9)

"log(0.9)" corresponds to a ~10% reduction of the original parameter value.
```{r}
# Which pars shall be perturbed?
pars_perturbed_0 <- pars_perturbed <- c("logx1" = log(0.9), "logy1" = log(0.9), "logz1" = log(0.9))

# pars_perturbed
p_pert <- p_pert_fun(pars_perturbed = pars_perturbed, pars = pars)
```

## Final parameter values for different Figures

Uncomment/comment the respective parameters that you want.

Parameters for Figures 3,4
```{r}
pars <- c(100,0,0,100,0,0,100,0,0,
          100,1.5,100,1,     0.01,0.4,0.05,
          100,5,            0.05,0.4,0.008,
          100,1,
          100,100,1,1,
          0,0,0,0,0,0,00,0,0,0,0,0,
          rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0))


pars_0 <- pars <- log(pars+.Machine$double.eps) %>% set_names(names(pars_0))
```

Parameters for Figure 5
```{r}
# pars <- c(100,0,0,100,0,0,100,0,0,
#           100,1.5,100,1,     0.002,0.4,0.05,
#           100,5,            0.005,0.4,0.05,
#           100,1,
#           100,100,1,1,
#           0,0,0,0,0,0,00,0,0,0,0,0,
#           rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0))
# pars_0 <- pars <- log(pars+.Machine$double.eps) %>% set_names(names(pars_0))
```


## Generate the perturbation data
```{r}
perturbation_prediction <-  (xs*p_log*p_pert)(times = c(0,Inf), pars = pars, deriv = F)

(x*p_log*p_pert)(times = seq(0,2000, length.out = 50), pars = pars) %>%
  plotPrediction()

perturbation_prediction %>% lapply(round,1)
```


# Apply the algorithm
This is an example of how the algorithm is applied.

Infer the network without complexes
```{r}
r_0 <-   R_fun(pars_opt = pars_opt_0,
               perturbation_prediction = perturbation_prediction,
               obs_fun = g,
               p_fun = (p_log*p_pert),
               pars = pars) %>% local_response_matrix_eq10()
r_0%>% round(2)
```

We need to consider complexes between X and Y and between Y and Z.
Scan through the parameters to choose which elements to keep in the optimization.

Often it suffices to compare two points of the parameter space, pars_opt = a_ij = 0 and pars_opt ~ 1.
```{r}
which_pars_opt <- c("loga_Cxy", "loga_Cyz")
r_kept_0 <- r_kept_fun(pars_opt = pars_opt[which_pars_opt],
                       perturbation_prediction = perturbation_prediction, 
                       obs_fun = g,
                       p_fun = (p_log * p_pert), 
                       pars = pars,
                       alpha = -log(0+.Machine$double.eps))
r_kept_0
```

Evaluate the objective function for demonstration.
```{r}
obj_alpha(pars_opt, fixed = NULL, perturbation_prediction = perturbation_prediction, r_kept = r_kept_0, obs_fun = g, p_fun = (p_log * p_pert), mypars = pars_0)
```

Optimize the objective function with trust region optimizer starting from multiple random starting points in our parameter space and take a look at the fits.

This method has proven to be the most stable.
```{r}
myfits <- mstrust(obj_alpha, center =  structure(rep(0, length(which_pars_opt)), names = which_pars_opt), studyname = "Fits", cores = 3, fits = 3, sd = 1, mypars = pars, perturbation_prediction = perturbation_prediction, r_kept = r_kept_0)

myfits %>% as.parframe()
```

Look at the resulting local response matrix, when the parameter values of the best fit are fed into our parametric local response matrix
```{r}
best_fit <- myfits %>% as.parframe() %>% as.parvec()
r_alpha_fun(pars_opt = unclass(best_fit), pars = pars, perturbation_prediction = perturbation_prediction) %>% round(2)
```


# Plots for main text
Run the algorithm for different values of the parameters which control the feedback.
Do this for the two different options of defining communicating species (adding them to both modules or only the upstream module).
Also, scan the pars_opt in a finer grid than in the section above.
```{r, eval=FALSE}
par_opt_names <- pars_opt_0 %>% names %>% sort

par_opt_settings <- list(par_opt_names[c(1,2)]
                         , par_opt_names[c(3,5)]
                         )

# Figure 4
pars <- c(100,0,0,100,0,0,100,0,0,
          100,1.5,100,1,     0.01,0.4,0.05,
          100,5,            0.05,0.4,0.008,
          100,1,
          100,100,1,1,
          0,0,0,0,0,0,00,0,0,0,0,0,
          rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0))


pars_0 <- pars <- log(pars+.Machine$double.eps) %>% set_names(names(pars_0))

dr_list <- lapply(seq_along(par_opt_settings), function(i) {
  # list(
  r_opt_dose_response(which_par = "loggainuf",
                      dosages = sort(unique(c(-9:5, seq(-3,3,by = 0.5)))),
                      pars = pars,
                      alpha_scan_range = seq(-3,3,by = 0.05),
                      pars_opt = pars_opt_0[par_opt_settings[[i]]])
  # )
})

# Figure 5

pars <- c(100,0,0,100,0,0,100,0,0,
          100,1.5,100,1,     0.002,0.4,0.05,
          100,5,            0.005,0.4,0.05,
          100,1,
          100,100,1,1,
          0,0,0,0,0,0,00,0,0,0,0,0,
          rep(0, length(pars_opt_0))) %>% set_names(names(pars_inner_0))
pars_0 <- pars <- log(pars+.Machine$double.eps) %>% set_names(names(pars_0))

dr_list2 <- lapply(seq_along(par_opt_settings), function(i) {
  r_opt_dose_response(which_par = "loggainlf",
                      dosages = sort(unique(c(-9:5, seq(-3,3,by = 0.5)))),
                      pars = pars,
                      alpha_scan_range = seq(-3,3,by = 0.05),
                      pars_opt = pars_opt_0[par_opt_settings[[i]]])
})
```


# Plot the results

## Figure 4
Plot as dose-response with alpha as facets
```{r Plot generation}
# load("Output/2017-07-24 dr_lists large complex concentrations.RData")
load("Output/dr_lists Cascade nice pars.RData")

myplot <- c(dr_list,dr_list2) %>% 
  combine_dr_list() %>%
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter(dose >= -2, dose <= 2.5) %>%
  filter(par_opt_setting == 1) %>% 
  filter(alpha %in% 0) %>%
  filter(matrix != "r_kept") %>%
  apply_expression({
    x$matrix[x$matrix == "r_alpha"] <- "r(a_i = 1)"
    x$matrix[x$matrix == "r_opt"] <- "r(a = a_opt)"
    x$matrix <- x$matrix %>% factor(levels = c("r(a_i = 1)", "r(a = a_opt)", "r_kept"))
    x
  }) %>% 
  mutate(Element = r_element) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = Element, linetype = Element)) +
  geom_line() +
  theme_dMod() +
  scale_color_dMod() +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  geom_vline(xintercept = 0, linetype = 3, size = 0.1) +
  facet_grid(matrix~., scales = "free")+
  xlab("log(gu)")

myplot

# look at them interactively with plotly:
# plotly::ggplotly(myplot)

# ggsave(plot = myplot,
#        filename = paste0("gu large sequestration",".png"),
#        width = 10,
#        height = 10,
#        units = "cm",
#        device = "png")

```

## Figure 5
```{r Plot generation}
myplot <- c(dr_list,dr_list2) %>% 
  combine_dr_list() %>%
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter(dose >= -2, dose <= 2.5) %>%
  filter(par_opt_setting == 3) %>% 
  filter(alpha %in% 0) %>%
  filter(matrix != "r_kept") %>%
  apply_expression({
    x$matrix[x$matrix == "r_alpha"] <- "r(a_i = 1)"
    x$matrix[x$matrix == "r_opt"] <- "r(a = a_opt)"
    x$matrix <- x$matrix %>% factor(levels = c("r(a_i = 1)", "r(a = a_opt)", "r_kept"))
    x
  }) %>% 
  mutate(Element = r_element) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = Element, linetype = Element)) +
  geom_line() +
  theme_dMod() +
  scale_color_dMod() +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  geom_vline(xintercept = 0, linetype = 3, size = 0.1) +
  facet_grid(matrix~., scales = "free")+
  xlab("log(gl)")

myplot

# look at them interactively with plotly:
# plotly::ggplotly(myplot)

# ggsave(plot = myplot,
#        filename = paste0("gl small sequestration",".png"),
#        width = 10,
#        height = 10,
#        units = "cm",
#        device = "png")

```



```{r dr_fun to give r_kept to the calculations, eval=FALSE}
r_opt_dose_response_given_r_kept <- function(which_par,
                                dosages,
                                alpha_scan_range = seq(-9,9,by = 2),
                                pars_opt = pars_opt_0,
                                obs_fun = g,
                                p_fun = (p_log * p_pert),
                                pars = pars_0,
                                r_kept) {


  r_names_0 <- paste0("r", outer(as.character(1:length(modules0)),as.character(1:length(modules0)), paste0))

  out <- lapply(dosages, function(dose) {

    pars[which_par] <- structure(dose, names = which_par)

    perturbation_prediction <-  (xs*p_fun)(times = c(0,Inf), pars = pars, deriv = F)

    # r_alpha to plot and to compute r_kept


    r_alpha_df <- sapply(alpha_scan_range, function(a) {
      # print(a)
      myr <- r_alpha_fun(pars_opt = structure(rep(a, length(pars_opt)), names = names(pars_opt)), # center around logalpha = 0
                         perturbation_prediction = perturbation_prediction,
                         obs_fun = obs_fun,
                         p_fun = p_fun,
                         pars = pars)
      return(myr)
    }) %>%
      t %>%
      structure(. , dimnames = list(NULL, r_names_0)) %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_alpha", gather_cols = r_names_0)


    # r_0
    r_0 <- r_alpha_fun(pars_opt = structure(rep(log(0+.Machine$double.eps), length(pars_opt)), names = names(pars_opt)),
                       perturbation_prediction = perturbation_prediction,
                       obs_fun = obs_fun,
                       p_fun = p_fun,
                       pars = pars)

    # r_kept
    r_kept_df <- sapply(alpha_scan_range, function(a) {
      return(r_kept)
    }) %>%
      add(seq(0,0.05,length.out = length(r_names_0))) %>%  # könnte man evtl auch mit "jitter" lösen
      t %>%
      structure(. , dimnames = list(NULL, r_names_0)) %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_kept", gather_cols = r_names_0)

    # r_kept <- r_kept_df  %>%  # könnte man evtl auch mit "jitter" lösen
    #   extract2(2) %>%
    #   is_greater_than(0.5) %>%
    #   matrix(ncol = (obs_fun %>% attr("ma") %>% extract2(1) %>% attr("eq") %>% length)) %>%
    #   t()

    # determine the alpha values at which a sign flip occured.
    flipped <- r_kept_df %>%
      tidyr::spread(r_element, r_kept) %>%
      select(-alpha) %>%
      apply(2, diff) %>%
      rbind(0,.) %>%
      apply(1, function(i) as.logical(i) %>% any)

    if(any(r_kept_df[r_kept_df[["alpha"]] == min(alpha_scan_range), "r_kept"]>0.5)) {
      flipped[1] <- TRUE
    }
    # when no sign flip occurs between two alphas, one can be sure that the alpha_opt, that is found will be found again.
    # No fitting is necessary in this case. Initialize an object (booh) to intermediately store the r_opt to be able to access it within the loop over the alphas
    r_opt_prev <- r_0
    best_fit_prev <- structure(rep(min(alpha_scan_range), length(pars_opt)), names = names(pars_opt))

    # r_opt
    r_opt_df <- sapply(seq_along(alpha_scan_range), function(i) {

      if(flipped[i]) { # if a sign flip occured in any of the matrix elements, optimize

        r_kept <- r_kept_df %>%
          dplyr::filter(alpha == alpha_scan_range[i] ) %>%
          extract2("r_kept") %>%
          is_greater_than(0.5) %>%
          matrix(nrow = length(modules0))

        assign("obj", obj_alpha, envir = .GlobalEnv)

        myfits <- mstrust(obj,
                          center =  structure(rep(-1, length(pars_opt)), names = names(pars_opt)), # center around log(pars_opt) = -1
                          studyname = "pars_controlled",
                          resultPath = ".pars_controlled/",
                          cores = 3,
                          fits = 9,
                          sd = 1,
                          perturbation_prediction = perturbation_prediction,
                          r_kept = r_kept,
                          obs_fun = obs_fun,
                          p_fun = p_fun,
                          mypars = pars,
                          iterlim = 50)

        mybest_fit <- try(myfits %>% as.parframe %>% as.parvec)

        #

        if(inherits(mybest_fit, "try-error")) {
          r_opt <- r_opt_prev
          mybest_fit <- best_fit_prev
        } else {
          # "prev" = previous wrt alpha, see further up, where r_opt_prev is constructed
          r_opt <- r_alpha_fun(pars_opt = mybest_fit,
                               perturbation_prediction = perturbation_prediction,
                               obs_fun = obs_fun,
                               p_fun = p_fun,
                               pars = pars)

          # save r_opt and bestfit outside of this environment
          r_opt_prev <<- r_opt
          best_fit_prev <<- mybest_fit
        }
      } else {
        r_opt <- r_opt_prev
        mybest_fit <- best_fit_prev
        # print(i)
      }

      r_opt <- c(r_opt, mybest_fit) %>% set_names(c(r_names_0, names(pars_opt)))

      return(r_opt)
    }) %>%
      t %>%
      cbind(alpha = alpha_scan_range, .) %>%
      as.data.frame(stringsAsFactors =  F) %>%
      tidyr::gather_(key = "r_element", value = "r_opt", gather_cols = r_names_0)


    steady_states <- (xs*p_fun)(times = c(0,Inf), pars = pars, deriv = F)
    if(any(steady_states[[1]][-1] > 95)) warning("Warning in dose level ", dose, ". Saturation might have been reached. \n", steady_states[[1]][-1], "\n")


    r_df <- plyr::join(r_alpha_df, r_kept_df) %>% plyr::join(r_opt_df)
    r_df <- data.frame(r_df, which_par = which_par, dose = dose)

    return(r_df)
  }) %>%
    do.call(rbind,.) %>%
    gather(key = "matrix", value  = "value", r_alpha, r_kept, r_opt) %>%
    gather_(key_col = "par_opt", value_col  = "par_opt_value", gather_cols = names(pars_opt))

}

```

```{r compute dr_list with given r_kept, eval=FALSE}
dr_list3 <- lapply(seq_along(par_opt_settings), function(i) {
  # list(
  r_opt_dose_response_given_r_kept(which_par = "loggainuf",
                      dosages = sort(unique(c( seq(-3,3,by = 0.5)))),
                      pars = pars,
                      alpha_scan_range = seq(-3,3,by = 0.05),
                      pars_opt = pars_opt_0[par_opt_settings[[i]]],
                      r_kept = c(F,F,F, T,F,F, F,T,F))
  # )
})

save(dr_list3, file = "Output/dr_list3 Cascade nice pars given r_kept.RData")


```


```{r Plot generation2}
# load("Output/2017-07-24 dr_lists large complex concentrations.RData")
load("Output/dr_lists Cascade nice pars.RData")
load("Output/dr_list3 Cascade nice pars given r_kept.RData")

myplot <- c(dr_list, dr_list2, dr_list3) %>% 
  combine_dr_list() %>%
  filter(! (r_element %in% paste0("r", c(11,22,33)))) %>% 
  filter(dose >= -2, dose <= 2.5) %>%
  filter(par_opt_setting == 5) %>% 
  filter(alpha %in% 0) %>% 
  # filter(matrix != "r_kept") %>%
  apply_expression({
    x$matrix[x$matrix == "r_alpha"] <- "r(a_i = 1)"
    x$matrix[x$matrix == "r_opt"] <- "r(a = a_opt)"
    x$matrix <- x$matrix %>% factor(levels = c("r(a_i = 1)", "r(a = a_opt)", "r_kept"))
    x
  }) %>% 
  mutate(Element = r_element) %>% 
  ggplot(mapping = aes(x = dose, y = value, color = Element, linetype = Element)) +
  geom_line() +
  theme_dMod() +
  scale_color_dMod() +
  geom_abline(slope = 0,intercept = 0, linetype = 3) +
  facet_grid(matrix~., scales = "free")+
  xlab("log(gu)")
plotly::ggplotly(myplot)
# ggsave(plot = myplot,
#        filename = paste0("~/Promotion/Writing/Papers/2017 02 MRA optimization procedure Paper/pictures/plots/", "gu largkjhkjhdstration",".png"),
#        width = 10,
#        height = 10,
#        units = "cm",
#        device = "png")

```





















